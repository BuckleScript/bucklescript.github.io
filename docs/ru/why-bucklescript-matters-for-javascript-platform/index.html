<!DOCTYPE html><html lang="ru"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>why-bucklescript-matters-for-javascript-platform · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="**Отказ:** Этот пост опининатирован, пожалуйста, примите его с зерном соли и сделайте свой собственный вызов."/><meta name="docsearch:language" content="ru"/><meta property="og:title" content="why-bucklescript-matters-for-javascript-platform · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/"/><meta property="og:description" content="**Отказ:** Этот пост опининатирован, пожалуйста, примите его с зерном соли и сделайте свой собственный вызов."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/redirectToNewDoc.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ru"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/ru/installation" target="_self">Docs</a></li><li class=""><a href="/docs/ru/playground" target="_self">Try</a></li><li class=""><a href="/docs/ru/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/ru/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Русский</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/why-bucklescript-matters-for-javascript-platform">日本語</a></li><li><a href="/docs/en/why-bucklescript-matters-for-javascript-platform">English</a></li><li><a href="/docs/es-ES/why-bucklescript-matters-for-javascript-platform">Español</a></li><li><a href="/docs/fr/why-bucklescript-matters-for-javascript-platform">Français</a></li><li><a href="/docs/ko/why-bucklescript-matters-for-javascript-platform">한국어</a></li><li><a href="/docs/pt-BR/why-bucklescript-matters-for-javascript-platform">Português (Brasil)</a></li><li><a href="/docs/zh-CN/why-bucklescript-matters-for-javascript-platform">中文</a></li><li><a href="/docs/zh-TW/why-bucklescript-matters-for-javascript-platform">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/bucklescript/ru" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">why-bucklescript-matters-for-javascript-platform</h1></header><article><div><span><p><strong>Отказ:</strong> Этот пост опининатирован, пожалуйста, примите его с зерном соли и сделайте свой собственный вызов.</p>
<h1><a class="anchor" aria-hidden="true" id="почему-я-должен-заботиться-о-bucklescript"></a><a href="#почему-я-должен-заботиться-о-bucklescript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Почему я должен заботиться о BuckleScript?</h1>
<p>BuckleScript предназначен для крупномасштабного программирования под платформой JavaScript .</p>
<p>Его цель не только работает OCaml программы под платформой JavaScript, , но и попытаться довести все инструменты разработчика Javascript до экосистемы OCaml , но и обеспечить безопасность и экспрессивность языка OCaml к сообществу разработчиков Javascript.</p>
<p>If you are interested in compilation-time cost that existing Javascript transpilers (<a href="https://babeljs.io/">babel</a>, <a href="http://buble.surge.sh/">buble</a> or <a href="https://github.com/google/traceur-compiler">traceur</a>) suffer from or projects like <a href="https://www.typescriptlang.org/">typescript</a>, <a href="http://elm-lang.org/">Elm</a>, or <a href="http://www.purescript.org/">Purescript</a> we think you will probably be interested in BuckleScript as well.</p>
<p>BuckleScript is not a new language. It reuses the existing <a href="https://ocaml.org/">OCaml programming language</a> while still delivering debug-able and performant JavaScript code. We think it’s better to reuse than having to invent a new language.</p>
<p>We think it’s important that BuckleScript compiles <strong>much faster</strong> than existing transpilers, generates <strong>more efficient code</strong> while keeping its Javascript output <strong>readable</strong>.</p>
<p>When in production mode, BuckleScript will aggressively eliminate dead code at the module level - more than just <a href="http://www.2ality.com/2015/12/webpack-tree-shaking.html">tree-shaking</a>, it will analyze the program to do a <a href="https://en.wikipedia.org/wiki/Pure_function">purity</a> analysis and eliminate anything that doesn’t have side-effects. On the global level, it produces code that is readily optimized by linker/bundlers such as the <a href="https://developers.google.com/closure/compiler/">Google Closure Compiler</a>.</p>
<p>Unlike most transpiled languages, BuckleScript generates <strong>much smaller code</strong> than hand-written Javascript, eliminating the need to split your libraries into small pieces like as done in <a href="https://github.com/lodash/lodash">lodash</a> - we think this should be the compiler and linker’s job.</p>
<h1><a class="anchor" aria-hidden="true" id="how-does-it-compare-with-other-transpilers"></a><a href="#how-does-it-compare-with-other-transpilers" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How does it compare with other transpilers?</h1>
<ol>
<li><p>It’s OCaml, and we think Ocaml is awesome. The OCaml language is actually, <strong>really close</strong> to JavaScript after <a href="https://en.wikipedia.org/wiki/Type_erasure">type-erasure</a>. Take <a href="http://www.purescript.org/">purescript</a> which is designed to generate readable Javascript for example, it’s essentially <a href="https://www.haskell.org/">Haskell</a> with strict evaluation semantics. If we just use OCaml instead, we don’t need invent a new language, since it already offers many of the benefits of Haskell, and has a strict evaluation order by default (one of the key differences from Haskell). Moreover, as alluded to, by its full name — Objective Caml, OCaml provides built-in support for Object Oriented programming. OCaml’s <a href="https://en.wikipedia.org/wiki/Structural_type_system">structural typing</a> and <a href="https://www.cl.cam.ac.uk/teaching/1415/L28/rows.pdf">row-polymorphism</a> captures the flexibility of Javascript programs very well — structural typing is a formalized way of duck-typing. As opposed to Haskell, OCaml does not have an (in our opinion) abstruse way of <a href="http://stackoverflow.com/questions/2488646/why-are-side-effects-modeled-as-monads-in-haskell">supporting side-effects</a>, in fact, while it encourages functional programming in general, it natively supports straightforward imperative programming and Object-Oriented programming when you really need it. As a practical programmers, we find this to be a big deal: While we prefer programming in a functional style in general, we realize there are some cases that an imperative style makes perfect sense.</p></li>
<li><p>BuckleScript is not just OCaml, but the whole OCaml ecosystem</p></li>
</ol>
<p>The OCaml compiler implementation(s) are famous for blazing fast compile times, and as programmer, we think compile times really matter and are a very important feature of a compiled language.</p>
<pre><code class="hljs">![./dist/images/compile-time.png](./dist/images/compile-time.png)
</code></pre>
<p>The above picture compares OCaml compilation-times with other languages: S for Scala, K for Koltin, TS for TypeScript.</p>
<p>BuckleScript reuses most of the OCaml compiler (parsing/type checking and pattern match compilation), its type checker <a href="http://okmij.org/ftp/ML/generalization.html">was well engineered</a> and written in an imperative style to make it fast.</p>
<p>Before BuckleScript, there already existed an <a href="./Differences-from-js_of_ocaml.adoc">OCaml to JS compiler</a>. BuckleScript stands on the shoulders of such excellent tools. For example, from the very beginning, much like Js_of_ocaml, BuckleScript has an assembly backend, which we use for the best performance in our development environment and our <a href="http://bucklescript.github.io/bucklescript-playground/">playground</a> to deliver the software to more people without installation - compared with Elm, Purescript, or typescript, none of which support both an ASM backend and a JS backend.</p>
<ol>
<li>BuckleScript is an optimizing compiler and will do much more in the future.</li>
</ol>
<p>Since OCaml has a sound type system, and functional languages are generally easier to optimize, unlike typescript, we’ve already done lots of optimizations for efficient Javascript output, and envision much more in the future.</p>
<p>Here’s a naive example to demonstrate the capabilities of BuckleScript:</p>
<p>The following OCaml code:</p>
<pre><code class="hljs">let test () =
  let m = ref IntMap.empty in
  let count = 1000000 in
  for i = 0 to count do
    m := IntMap.add i i !m
  done;
  for i = 0 to count do
    ignore (IntMap.find i !m)
  done

let () = test()
</code></pre>
<p>Generates the following output code:</p>
<pre><code class="hljs">function test() {
  var m = /* Empty */0;
  for(var i = 0; i&lt;= 1000000; ++i){
    m = add(i, i, m);
  }
  for(var i$1 = 0; i$1&lt;= 1000000; ++i$1){
    find(i$1, m);
  }
  return /* () */0;
}

test(/* () */0);
</code></pre>
<p>We re-wrote the example using using Facebook’s <a href="http://facebook.github.io/immutable-js/">immutable</a> library for JavaScript</p>
<pre><code class="hljs">'use strict';
var Immutable = require('immutable');
var Map = Immutable.Map;
var m = new Map();
var test = function() {
  var count = 1000000;
  for(var i = 0; i &lt; count; ++i) {
    m = m.set(i, i);
   }
  for(var j = 0; j &lt; count; ++j) {
    m.get(j);
    }
}

test();
</code></pre>
<p>Now we compare the runtime performance:</p>
<ul>
<li><p>BuckleScript Immutable Map: 1186ms</p></li>
<li><p>Facebook Immutable Map: 3415ms</p></li>
</ul>
<p>We also compare code Size:</p>
<ul>
<li><p>BuckleScript (Prod mode): 899 Bytes</p></li>
<li><p>Facebook Immutable: 55.3K Bytes</p></li>
</ul>
<h1><a class="anchor" aria-hidden="true" id="how-is-it-faster-than-hand-written-js-code"></a><a href="#how-is-it-faster-than-hand-written-js-code" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How is it faster than hand-written JS code?</h1>
<p>It’s hard to explain JS performances in general, however, we will explain some of the optimizations we’ve done. For example, in OCaml, <code>Map</code> is like C++ templates, i.e. it will be instantiated by a comparison function, like below:</p>
<pre><code class="hljs">module IntMap = Map.Make(struct
  type t = int
  let compare (x : int) y = compare x y
  end
)
</code></pre>
<p>In BuckleScript, this instantiation happens at compile time instead of at runtime, thereby improving the performance. Moreover, the data representation or encoding of types is also optimized for speed. Consider the following example:</p>
<pre><code class="hljs">(** Map.t *)
type 'a t =
  | Empty
  | Node of 'a t * key * 'a * 'a t * int
</code></pre>
<p>Since there are only two branches in this <a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data type</a>, <code>Empty</code> will be simply encoded as <code>0 /* Empty */</code> (with comments for readable output) and <code>Node(l, x, data, r, height)</code> will be encoded as <code>/*Node*/ [l,x,data,r,height]</code>. Arrays are <a href="http://stackoverflow.com/questions/17295056/array-vs-object-efficiency-in-javascript">faster</a> for most operations when compared to objects.</p>
<p>Другие оптимизации, такие как <a href="http://stackoverflow.com/questions/310974/what-is-tail-call-optimization">хвост вызов конверсия</a>, встроенный и <a href="https://en.wikipedia.org/wiki/Constant_folding">постоянная распространение</a> также введены.</p>
<h1><a class="anchor" aria-hidden="true" id="как-это-уменьшает-размер-генерируемого-кода"></a><a href="#как-это-уменьшает-размер-генерируемого-кода" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Как это уменьшает размер генерируемого кода?</h1>
<p>Мы делаем три уровня ликвидации мертвых кодов. На модуле и функции уровней, BuckleScript попытается найти мертвый код и удалить неиспользуемые значения и побочные выражения (локальные переменные и функции). На уровне линкера/бундлера , BuckleScript может использовать существующие бундеры и даже Google Closure Compiler или любой существующий бундлер для выполнения глобального анализа , потому что мы производим код, соответствующий стандарту.</p>
<p>Даже запуск пряжки написан в самом OCaml, это означает, что такое время выполнения также может извлечь пользу из ликвидации мертвых кодов.</p>
<p>Есть и другие факторы, в основном код, организованный в функциональном стиле гораздо проще сделать трясение дерева, в то время как труднее удалить для OO стиль, стандартная библиотека OCaml и время выполнения организованы в независимый стиль, который также помогает удалить мертвый код.</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"></nav></div><span></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ru"]}
              });
            </script></body></html>