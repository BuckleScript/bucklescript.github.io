<!DOCTYPE html><html lang="ru"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Объект · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="JavaScript objects are used for two major purposes:"/><meta name="docsearch:language" content="ru"/><meta property="og:title" content="Объект · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/"/><meta property="og:description" content="JavaScript objects are used for two major purposes:"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/redirectToNewDoc.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/ru"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/ru/installation" target="_self">Docs</a></li><li class=""><a href="/docs/ru/playground" target="_self">Try</a></li><li class="siteNavGroupActive"><a href="/docs/ru/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/ru/community" target="_self">Community</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>Русский</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/docs/ja/object">日本語</a></li><li><a href="/docs/en/object">English</a></li><li><a href="/docs/es-ES/object">Español</a></li><li><a href="/docs/fr/object">Français</a></li><li><a href="/docs/ko/object">한국어</a></li><li><a href="/docs/pt-BR/object">Português (Brasil)</a></li><li><a href="/docs/zh-CN/object">中文</a></li><li><a href="/docs/zh-TW/object">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Interop</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Intro</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/what-why">What &amp; Why</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/installation">Установка</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/new-project">Новый Проект</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/try">Try</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/concepts-overview">Обзор концепций</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/upgrade-to-v7">Upgrade Guide to v7</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Interop</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/interop-overview">Обзор</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/interop-cheatsheet">Шеатхет</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/embed-raw-javascript">Вставить сырый JavaScript</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/common-data-types">Общие типы данных</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/intro-to-external">Введение во внешний</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/bind-to-global-values">Привязка к глобальным значениям</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/null-undefined-option">Null, Undefined и Option</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/ru/object">Объект</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/object-2">Объект 2</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/class">Класс</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/function">Функция</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/property-access">Property access</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/return-value-wrapping">Return value wrapping</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/import-export">Импорт / Экспорт</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/regular-expression">Регулярное выражение</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/exceptions">Необработанные карты</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/json">JSON</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/pipe-first">Пиппа первая</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/generate-converters-accessors">Создать конвертеры и помощники</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/better-data-structures-printing-debug-mode">Улучшение печати структур данных (режим отладки)</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/nodejs-special-variables">Специальные переменные NodeJS</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/interop-misc">Прочее</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/browser-support-polyfills">Поддержка браузера и полифилы</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Build System</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/build-overview">Обзор</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/build-configuration">Настройки</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/automatic-interface-generation">Автоматическое поколение интерфейса</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/interop-with-js-build-systems">Взаимодействие с другой системой сборки</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/build-performance">Производительность</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/build-advanced">Передовой</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Standard Library</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/stdlib-overview">Overview</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Advanced</h3><ul class=""><li class="navListItem"><a class="navItem" href="/docs/ru/conditional-compilation">Условная компиляция</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/extended-compiler-options">Расширенные настройки компилятора</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/use-existing-ocaml-libraries">Use Existing OCaml Libraries</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/difference-from-native-ocaml">Различия от Native OCaml</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/compiler-architecture-principles">Архитектура и принципы компилятора</a></li><li class="navListItem"><a class="navItem" href="/docs/ru/comparison-to-jsoo">Сравнение с Js_ocaml</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://crowdin.com/project/bucklescript/ru" target="_blank" rel="noreferrer noopener">Translate</a><h1 class="postHeaderTitle">Объект</h1></header><article><div><span><p>JavaScript objects are used for two major purposes:</p>
<ul>
<li>As a <strong>hash map</strong> (or &quot;dictionary&quot;), where keys can be dynamically added/removed and where values are of the same type.</li>
<li>As a <strong>record</strong>, where fields are fixed (though still maybe sometimes optional) and where values can be of different types.</li>
</ul>
<p>Correspondingly, BuckleScript works with JS objects in these 2 ways.</p>
<h2><a class="anchor" aria-hidden="true" id="hash-map-mode"></a><a href="#hash-map-mode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hash Map Mode</h2>
<p>Until recently, where JS finally got proper Map support, objects have been (ab)used as a map. If you use your JS object like this:</p>
<ul>
<li>might or might not add/remove arbitrary keys</li>
<li>values might or might not be accessed using a dynamic/computed key</li>
<li>values are all of the same type</li>
</ul>
<p>Then use our <a href="https://bucklescript.github.io/bucklescript/api/Js.Dict.html"><code>Js.Dict</code></a> (for &quot;dictionary&quot;) API to bind to that JS object! In this mode, you can do all the metaprogramming you're used to with JS objects: get all keys through <code>Js.Dict.keys</code>, get values through <code>Js.Dict.values</code>, etc.</p>
<h3><a class="anchor" aria-hidden="true" id="пример"></a><a href="#пример" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Пример</h3>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* Create a JS object ourselves *)</span>
<span class="hljs-keyword">let</span> myMap = <span class="hljs-type">Js</span>.<span class="hljs-type">Dict</span>.empty <span class="hljs-literal">()</span>
<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = <span class="hljs-type">Js</span>.<span class="hljs-type">Dict</span>.set myMap <span class="hljs-string">"Allison"</span> <span class="hljs-number">10</span>

<span class="hljs-comment">(* Use an existing JS object *)</span>
<span class="hljs-keyword">external</span> studentAges : <span class="hljs-built_in">int</span> <span class="hljs-type">Js</span>.<span class="hljs-type">Dict</span>.t = <span class="hljs-string">"student"</span> [@@bs.<span class="hljs-keyword">val</span>]
<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> =
  <span class="hljs-keyword">match</span> <span class="hljs-type">Js</span>.<span class="hljs-type">Dict</span>.get studentAges <span class="hljs-string">"Joe"</span> <span class="hljs-keyword">with</span>
  | <span class="hljs-type">None</span> -&gt; <span class="hljs-type">Js</span>.log <span class="hljs-string">"Joe can't be found"</span>
  | <span class="hljs-type">Some</span> age -&gt; <span class="hljs-type">Js</span>.log (<span class="hljs-string">"Joe is "</span> ^ (string_of_int age))
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* Create a JS object ourselves */</span>
<span class="hljs-keyword">let</span> myMap = <span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">Dict</span>.empty();
<span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">Dict</span>.set(myMap, <span class="hljs-string">"Allison"</span>, <span class="hljs-number">10</span>);

<span class="hljs-comment">/* Use an existing JS object */</span>
<span class="hljs-attribute">[@bs.val]</span> <span class="hljs-keyword">external</span> studentAges : <span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">Dict</span>.t(int) = <span class="hljs-string">"student"</span>;
<span class="hljs-keyword">switch</span> (<span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">Dict</span>.get(studentAges, <span class="hljs-string">"Joe"</span>)) {
| <span class="hljs-constructor">None</span> =&gt; <span class="hljs-module-identifier">Js</span>.log(<span class="hljs-string">"Joe can't be found"</span>)
| <span class="hljs-constructor">Some</span>(age) =&gt; <span class="hljs-module-identifier">Js</span>.log(<span class="hljs-string">"Joe is "</span> <span class="hljs-operator">++</span> string_of_int(age))
};
</code></pre>
<p>Output:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> Js_dict = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./stdlib/js_dict.js"</span>);

<span class="hljs-keyword">var</span> myMap = { };

myMap[<span class="hljs-string">"Allison"</span>] = <span class="hljs-number">10</span>;

<span class="hljs-keyword">var</span> match = Js_dict.get(student, <span class="hljs-string">"Joe"</span>);

<span class="hljs-keyword">if</span> (match !== <span class="hljs-literal">undefined</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Joe is "</span> + <span class="hljs-built_in">String</span>(match));
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Joe can't be found"</span>);
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="design-decisions"></a><a href="#design-decisions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Design Decisions</h3>
<p>You can see that under the hood, a <code>Js.Dict</code> is simply backed by a JS object. The entire API uses nothing but ordinary BuckleScript <code>external</code>s and wrappers, so the whole API mostly disappears after compilation. It is very convenient when converting files over from JS to BuckleScript.</p>
<h2><a class="anchor" aria-hidden="true" id="records-as-objects"></a><a href="#records-as-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Records as Objects</h2>
<blockquote>
<p><strong>Note:</strong> Requires BuckleScript &gt;= v7</p>
</blockquote>
<p>In BuckleScript, records are directly compiled into JS objects with the same shape (same attribute names). As long as your record doesn't contain any BS specific data structures (variants, lists), it will almost always compile to idiomatic JS (this includes nested records etc.):</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> pet =
  | <span class="hljs-constructor">Dog</span>
  | <span class="hljs-constructor">Cat</span>;

<span class="hljs-keyword">type</span> bloodGroup =
  | <span class="hljs-constructor">A</span>
  | <span class="hljs-constructor">B</span>;

<span class="hljs-keyword">type</span> person = {
  name: string,
  friends: array(string),
  pet: option(pet),
  age: int,
  <span class="hljs-comment">/* let's pretend our JS expects a null here */</span>
  bloodGroup: <span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">Nullable</span>.t(bloodGroup), 
};

<span class="hljs-keyword">let</span> john = {
  name: <span class="hljs-string">"John"</span>,
  pet: <span class="hljs-constructor">None</span>,
  friends: <span class="hljs-literal">[|</span><span class="hljs-string">"Anna"</span>, <span class="hljs-string">"Brad"</span>, <span class="hljs-string">"Shin"</span><span class="hljs-literal">|]</span>,
  age: <span class="hljs-number">20</span>,
  bloodGroup: <span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">Nullable</span>.null,
};
</code></pre>
<p>will be compiled into:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> john_friends = <span class="hljs-comment">/* array */</span>[
  <span class="hljs-string">"Anna"</span>,
  <span class="hljs-string">"Brad"</span>,
  <span class="hljs-string">"Shin"</span>
];

<span class="hljs-keyword">var</span> john_bloodGroup = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">var</span> john = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span>,
  <span class="hljs-attr">friends</span>: john_friends,
  <span class="hljs-attr">pet</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,
  <span class="hljs-attr">bloodGroup</span>: john_bloodGroup
};

</code></pre>
<p><strong>Please note:</strong> - You will still be required to transform variants and lists, so for seamless interop, make sure to only use <a href="/docs/en/common-data-types">common data types</a>, such as array, string, int, float, etc. Alternatively you can use <a href="https://github.com/cristianoc/genType">genType</a> to do automatic convertions between JS &lt;-&gt; BuckleScript values as well. - <code>None</code> (<code>option</code>) values are converted to <code>undefined</code>, so if your JS code distincts between <code>null</code> and <code>undefined</code>, use <code>Js.Nullable.t</code> instead</p>
<h3><a class="anchor" aria-hidden="true" id="rename-fields-bsas"></a><a href="#rename-fields-bsas" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rename fields - [bs.as]</h3>
<p>There are often situations where specific record attributes need to have a different name than then resulting JS object. The most prominent example would include names like <code>type</code>, which are often used for &quot;Action&quot; based patterns in JS, but cannot be expressed in BuckleScript, since <code>type</code> is a keyword.</p>
<p>To work around that, you can use the <code>[@bs.as]</code> attribute to change the target name within the resulting JS object:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> action = {
  <span class="hljs-attribute">[@bs.as "type"]</span> _type: string,
};

<span class="hljs-keyword">let</span> action = { _type: <span class="hljs-string">"ADD_USER"</span> };
</code></pre>
<p>will be compiled to:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> action = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">"ADD_USER"</span>
};
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="mutable-fields"></a><a href="#mutable-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutable fields</h3>
<p>You can also use the <code>mutable</code> keyword to do your side-effectual work:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> person = {
  <span class="hljs-keyword">mutable</span> name: string
};

<span class="hljs-keyword">let</span> p = {name: <span class="hljs-string">"Franz"</span>};
p.name = <span class="hljs-string">"Sabine"</span>;
</code></pre>
<p>which will translate cleanly to:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> p = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Franz"</span>
};

p.name = <span class="hljs-string">"Sabine"</span>;

</code></pre>
<h2><a class="anchor" aria-hidden="true" id="abstract-record-mode"></a><a href="#abstract-record-mode" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Abstract Record Mode</h2>
<blockquote>
<p><strong>Note</strong>: For BuckleScript &gt;= v7, we recommend using the plain <a href="#records-as-objects">Record as Objects</a> mechanic. This feature might still be useful for certain scenarios, but the ergonomics might be worse</p>
</blockquote>
<p>If your JS object:</p>
<ul>
<li>has a known, fixed set of fields</li>
<li>might or might not contain values of different types</li>
</ul>
<p>Then you're really using it like a &quot;record&quot; in most other languages. For example, think of the difference of use-case and intent between the object <code>{&quot;John&quot;: 10, &quot;Allison&quot;: 20, &quot;Jimmy&quot;: 15}</code> and <code>{name: &quot;John&quot;, age: 10, job: &quot;CEO&quot;}</code>. The former case would be the aforementioned &quot;hash map mode&quot;. The latter would be &quot;abstract record mode&quot;, which in BuckleScript is modeled with the <code>bs.deriving abstract</code> feature:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> person = {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">int</span>;
  job: <span class="hljs-built_in">string</span>;
} [@@bs.deriving abstract]

<span class="hljs-keyword">external</span> john : person = <span class="hljs-string">"john"</span> [@@bs.<span class="hljs-keyword">val</span>]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> person = {
  name: string,
  age: int,
  job: string,
};

<span class="hljs-attribute">[@bs.val]</span> <span class="hljs-keyword">external</span> john : person = <span class="hljs-string">"john"</span>;
</code></pre>
<p><strong>Note</strong>: the <code>person</code> type is <strong>not</strong> a record! It's a record-looking type that uses the record's syntax and type-checking. The <code>bs.deriving abstract</code> annotation turns it into an &quot;abstract type&quot; (aka you don't know what the actual value's shape).</p>
<h3><a class="anchor" aria-hidden="true" id="creation"></a><a href="#creation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creation</h3>
<p>You don't have to bind to an existing <code>person</code> object from the JS side. You can also create such <code>person</code> JS object from BuckleScript's side.</p>
<p>Since <code>bs.deriving abstract</code> turns the above <code>person</code> record into an abstract type, you can't directly create a person record as you would usually. This doesn't work: <code>{name: &quot;Joe&quot;, age: 20, job: &quot;teacher&quot;}</code>.</p>
<p>Instead, you'd use the <strong>creation function</strong> of the same name as the record type, implicitly generated by the <code>bs.deriving abstract</code> annotation:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> joe = person ~name:<span class="hljs-string">"Joe"</span> ~age:<span class="hljs-number">20</span> ~job:<span class="hljs-string">"teacher"</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> joe = person(~name=<span class="hljs-string">"Joe"</span>, ~age=<span class="hljs-number">20</span>, ~job=<span class="hljs-string">"teacher"</span>)
</code></pre>
<p>Output:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> joe = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">"Joe"</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>,
  <span class="hljs-attr">job</span>: <span class="hljs-string">"teacher"</span>
};
</code></pre>
<p>Look ma, no runtime cost!</p>
<h4><a class="anchor" aria-hidden="true" id="rename-fields"></a><a href="#rename-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Rename Fields</h4>
<p>Sometimes you might be binding to a JS object with field names that are invalid in BuckleScript/Reason. Two examples would be <code>{type: &quot;foo&quot;}</code> (reserved keyword in BS/Reason) and <code>{&quot;aria-checked&quot;: true}</code>. Choose a valid field name then use <code>[@bs.as]</code> to circumvent this:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> data = {
  type_: <span class="hljs-built_in">string</span> [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"type"</span>];
  ariaLabel: <span class="hljs-built_in">string</span> [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"aria-label"</span>];
} [@@bs.deriving abstract]

<span class="hljs-keyword">let</span> d = data ~type_:<span class="hljs-string">"message"</span> ~ariaLabel:<span class="hljs-string">"hello"</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> data = {
  <span class="hljs-attribute">[@bs.as "type"]</span> type_: string,
  <span class="hljs-attribute">[@bs.as "aria-label"]</span> ariaLabel: string,
};

<span class="hljs-keyword">let</span> d = data(~type_=<span class="hljs-string">"message"</span>, ~ariaLabel=<span class="hljs-string">"hello"</span>);
</code></pre>
<p>Output:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> d = {
  <span class="hljs-attr">type</span>: <span class="hljs-string">"message"</span>,
  <span class="hljs-string">"aria-label"</span>: <span class="hljs-string">"hello"</span>
};
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="optional-labels"></a><a href="#optional-labels" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Optional Labels</h4>
<p>You can omit fields during the creation of the object:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> person = {
  name: <span class="hljs-built_in">string</span> [@bs.optional];
  age: <span class="hljs-built_in">int</span>;
  job: <span class="hljs-built_in">string</span>;
} [@@bs.deriving abstract]

<span class="hljs-keyword">let</span> joe = person ~age:<span class="hljs-number">20</span> ~job:<span class="hljs-string">"teacher"</span> <span class="hljs-literal">()</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> person = {
  <span class="hljs-attribute">[@bs.optional]</span> name: string,
  age: int,
  job: string,
};

<span class="hljs-keyword">let</span> joe = person(~age=<span class="hljs-number">20</span>, ~job=<span class="hljs-string">"teacher"</span>, ());
</code></pre>
<p><strong>Note</strong> that the <code>[@bs.optional]</code> tag turned the <code>name</code> field optional. Merely typing <code>name</code> as <code>option(string)</code> wouldn't work.</p>
<p><strong>Note</strong>: now that your creation function contains optional fields, we mandate an unlabeled <code>()</code> at the end to indicate that <a href="https://reasonml.github.io/docs/en/function.html#optional-labeled-arguments">you've finished applying the function</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="accessors"></a><a href="#accessors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Accessors</h3>
<p>Again, since <code>bs.deriving abstract</code> hides the actual record shape, you can't access a field using e.g. <code>joe.age</code>. We remediate this by generating getter and setters.</p>
<h4><a class="anchor" aria-hidden="true" id="read"></a><a href="#read" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Read</h4>
<p>One getter function is generated per <code>bs.deriving abstract</code> record type field. In the above example, you'd get 3 functions: <code>nameGet</code>, <code>ageGet</code>, <code>jobGet</code>. They take in a <code>person</code> value and return <code>string</code>, <code>int</code>, <code>string</code> respectively:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> twenty = ageGet joe
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> twenty = ageGet(joe)
</code></pre>
<p>Alternatively, you can use the <a href="/docs/ru/pipe-first">Pipe First</a> feature in a later section for a nicer-looking access syntax:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> twenty = joe |. ageGet
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> twenty = joe<span class="hljs-operator">-&gt;</span>ageGet
</code></pre>
<p>If you prefer shorter names for the getter functions, <a href="https://bucklescript.github.io/blog/2019/03/21/release-5-0">we also support a 'light' setting</a>:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> person = {
  name: <span class="hljs-built_in">string</span>;
  age: <span class="hljs-built_in">int</span>;
} [@@bs.deriving {abstract = light}]

<span class="hljs-keyword">let</span> joe = person ~name:<span class="hljs-string">"Joe"</span> ~age:<span class="hljs-number">20</span>
<span class="hljs-keyword">let</span> joeName = name joe
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving {abstract: light}]</span>
<span class="hljs-keyword">type</span> person = {
  name: string,
  age: int,
};

<span class="hljs-keyword">let</span> joe = person(~name=<span class="hljs-string">"Joe"</span>, ~age=<span class="hljs-number">20</span>);
<span class="hljs-keyword">let</span> joeName = name(joe);
</code></pre>
<p>The getter functions will now have the same names as the object fields themselves.</p>
<h4><a class="anchor" aria-hidden="true" id="write"></a><a href="#write" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Write</h4>
<p>A <code>bs.deriving abstract</code> value is immutable by default. To mutate such value, you need to first mark one of the abstract record field as <code>mutable</code>, the same way you'd mark a normal record as mutable:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> person = {
  name: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">mutable</span> age: <span class="hljs-built_in">int</span>;
  job: <span class="hljs-built_in">string</span>;
} [@@bs.deriving abstract]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> person = {
  name: string,
  <span class="hljs-keyword">mutable</span> age: int,
  job: string,
};
</code></pre>
<p>Then, a setter of the name <code>ageSet</code> will be generated. Use it like so:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> joe = person ~name:<span class="hljs-string">"Joe"</span> ~age:<span class="hljs-number">20</span> ~job:<span class="hljs-string">"teacher"</span>
<span class="hljs-keyword">let</span> <span class="hljs-literal">()</span> = ageSet joe <span class="hljs-number">21</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> joe = person(~name=<span class="hljs-string">"Joe"</span>, ~age=<span class="hljs-number">20</span>, ~job=<span class="hljs-string">"teacher"</span>);
ageSet(joe, <span class="hljs-number">21</span>);
</code></pre>
<p>Alternatively, with the Pipe First syntax:</p>
<pre><code class="hljs css language-ocaml">joe |. ageSet <span class="hljs-number">21</span>
</code></pre>
<pre><code class="hljs css language-reason">joe<span class="hljs-operator">-&gt;</span>ageSet(<span class="hljs-number">21</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="methods"></a><a href="#methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Methods</h3>
<p>You can attach arbitrary methods onto a type (<em>any</em> type, as a matter of fact. Not just <code>bs.deriving abstract</code> record types). See <a href="/docs/ru/function#object-method">Object Method</a> in the function section later.</p>
<h3><a class="anchor" aria-hidden="true" id="tips-tricks"></a><a href="#tips-tricks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tips &amp; Tricks</h3>
<p>You can leverage <code>bs.deriving abstract</code> for finer-grained access control.</p>
<h4><a class="anchor" aria-hidden="true" id="mutability"></a><a href="#mutability" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mutability</h4>
<p>You can mark a field as mutable in the implementation (<code>ml</code>/<code>re</code>) file, while <em>hiding</em> such mutability in the interface file:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* test.ml *)</span>
<span class="hljs-keyword">type</span> cord = {
  <span class="hljs-keyword">mutable</span> x: <span class="hljs-built_in">int</span> [@bs.optional];
  y: <span class="hljs-built_in">int</span>;
} [@@bs.deriving abstract]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* test.re */</span>
<span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> cord = {
  <span class="hljs-attribute">[@bs.optional]</span> <span class="hljs-keyword">mutable</span> x: int,
  y: int,
};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* test.mli *)</span>
<span class="hljs-keyword">type</span> cord = {
  x: <span class="hljs-built_in">int</span> [@bs.optional];
  y: <span class="hljs-built_in">int</span>;
} [@@bs.deriving abstract]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-comment">/* test.rei */</span>
<span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> cord = {
  <span class="hljs-attribute">[@bs.optional]</span> x: int,
  y: int,
};
</code></pre>
<p>Tada! Now you can mutate inside your own file as much as you want, and prevent others from doing so!</p>
<h4><a class="anchor" aria-hidden="true" id="hide-the-creation-function"></a><a href="#hide-the-creation-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Hide the Creation Function</h4>
<p>Mark the record as <code>private</code> to disable the creation function:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> cord = <span class="hljs-keyword">private</span> {
  x: <span class="hljs-built_in">int</span> [@bs.optional];
  y: <span class="hljs-built_in">int</span>
} [@@bs.deriving abstract]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> cord = <span class="hljs-keyword">pri</span> {
  <span class="hljs-attribute">[@bs.optional]</span> x: int,
  y: int,
};
</code></pre>
<p>The accessors are still there, but you can no longer create such data structure. Great for binding to a JS object while preventing others from creating more such object!</p>
<h4><a class="anchor" aria-hidden="true" id="use-submodules-to-prevent-naming-collisions-and-binding-shadowing"></a><a href="#use-submodules-to-prevent-naming-collisions-and-binding-shadowing" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use submodules to prevent naming collisions and binding shadowing</h4>
<p>Oftentimes you will have multiple abstract types with similar attributes. Since BuckleScript will expand all abstract getter, setter and creation functions in the same scope where the type is defined, you will eventually run into value shadowing problems.</p>
<p><strong>For example:</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> person = {name: string};

<span class="hljs-attribute">[@bs.deriving abstract]</span>
<span class="hljs-keyword">type</span> cat = {
  name: string,
  isLazy: bool,
};

<span class="hljs-keyword">let</span> person = person(~name=<span class="hljs-string">"Alice"</span>);

<span class="hljs-comment">/* Error: This expression has type person but an expression was expected
   of type cat */</span>
person<span class="hljs-operator">-&gt;</span>nameGet();
</code></pre>
<p>To get around this issue, you can use modules to group a type with its related functions and later use them via local open statements:</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Person</span> = {
  <span class="hljs-attribute">[@bs.deriving abstract]</span>
  <span class="hljs-keyword">type</span> t = {name: string};
};

<span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Cat</span> = {
  <span class="hljs-attribute">[@bs.deriving abstract]</span>
  <span class="hljs-keyword">type</span> t = {
    name: string,
    isLazy: bool,
  };
};

<span class="hljs-keyword">let</span> person = <span class="hljs-module-identifier">Person</span>.t(~name=<span class="hljs-string">"Alice"</span>);
<span class="hljs-keyword">let</span> cat = <span class="hljs-module-identifier">Cat</span>.t(~name=<span class="hljs-string">"Snowball"</span>, ~isLazy=<span class="hljs-literal">true</span>);

<span class="hljs-comment">/* We can use each nameGet function separately now */</span>
<span class="hljs-keyword">let</span> shoutPersonName = <span class="hljs-module-identifier">Person</span>.(person<span class="hljs-operator">-&gt;</span>nameGet<span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">String</span>.toUpperCase);

<span class="hljs-comment">/* Note how we use a local open Cat.([some expression]) to 
   get access to Cat's nameGet function */</span>
<span class="hljs-keyword">let</span> whisperCatName = <span class="hljs-module-identifier">Cat</span>.(cat<span class="hljs-operator">-&gt;</span>nameGet<span class="hljs-operator">-&gt;</span><span class="hljs-module-identifier">Js</span>.<span class="hljs-module-identifier">String</span>.toLowerCase);
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/ru/null-undefined-option"><span class="arrow-prev">← </span><span>Null, Undefined и Option</span></a><a class="docs-next button" href="/docs/ru/object-2"><span>Объект 2</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#hash-map-mode">Hash Map Mode</a><ul class="toc-headings"><li><a href="#пример">Пример</a></li><li><a href="#design-decisions">Design Decisions</a></li></ul></li><li><a href="#records-as-objects">Records as Objects</a><ul class="toc-headings"><li><a href="#rename-fields-bsas">Rename fields - [bs.as]</a></li><li><a href="#mutable-fields">Mutable fields</a></li></ul></li><li><a href="#abstract-record-mode">Abstract Record Mode</a><ul class="toc-headings"><li><a href="#creation">Creation</a></li><li><a href="#accessors">Accessors</a></li><li><a href="#methods">Methods</a></li><li><a href="#tips-amp-tricks">Tips &amp; Tricks</a></li></ul></li></ul></nav></div><span></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:ru"]}
              });
            </script></body></html>