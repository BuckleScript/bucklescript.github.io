<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Blog · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A faster, simpler and more robust take on JavaScript."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Blog · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/"/><meta property="og:description" content="A faster, simpler and more robust take on JavaScript."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/redirectToNewDoc.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="blog"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/installation" target="_self">Docs</a></li><li class=""><a href="/docs/en/playground" target="_self">Try</a></li><li class=""><a href="/docs/en/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class="siteNavGroupActive siteNavItemActive"><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2020/05/06/exception-encoding">A story of exception encoding in BuckleScript</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/04/13/release-7-3">What&#x27;s new in release 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/26/generalize-uncurry">Generalized uncurry support in BuckleScript 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/12/release-7-2">Announcing bs-platform  7.2</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/20/loading-stdlib-in-memory">Loading stdlib from memory</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="posts"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/05/06/exception-encoding">A story of exception encoding in BuckleScript</a></h1><p class="post-meta">May 6, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>We just recently made some significant improvements with our new exception encoding and we find it so exciting that we want to highlight the changes and explain a little bit how exceptions work when compiling to JS.</p>
<p>The new encoding allows us to provide proper, clear stacktrace information whenever a Reason/OCaml exception is thrown. This is particularly important when you have some code running in production that needs to collect those stacktrace for diagnostics.</p>
<p>What's the difference?</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">exception</span> My_exception { x : <span class="hljs-built_in">int</span>};

<span class="hljs-keyword">let</span> loop =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> {
 for (i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> <span class="hljs-keyword">to</span> <span class="hljs-number">100</span>) {
   <span class="hljs-keyword">if</span> (i<span class="hljs-operator"> == </span><span class="hljs-number">10</span>) {
     raise (My_exception { x : i})
   };
 };
};
loop <span class="hljs-literal">()</span>;
</code></pre>
<p>When we compile and run this piece of code with the old exception encoding, this is what we'd get:</p>
<pre><code class="hljs">exn_demo$node src<span class="hljs-operator">/</span>exn_demo.bs.js 

<span class="hljs-operator">/</span><span class="hljs-constructor">Users</span><span class="hljs-operator">/</span>hongbozhang<span class="hljs-operator">/</span>git<span class="hljs-operator">/</span>exn_demo<span class="hljs-operator">/</span>src<span class="hljs-operator">/</span>exn_demo.bs.js:<span class="hljs-number">11</span>
      throw <span class="hljs-literal">[</span>
      <span class="hljs-operator">^</span>
<span class="hljs-literal">[</span> <span class="hljs-literal">[</span> '<span class="hljs-module-identifier">Exn_demo</span>.<span class="hljs-constructor">My_exception</span>', <span class="hljs-number">1</span>, tag: <span class="hljs-number">248</span> <span class="hljs-literal">]</span>, <span class="hljs-number">10</span> <span class="hljs-literal">]</span>
</code></pre>
<p>With our new improvements, we now get way better results:</p>
<pre><code class="hljs">bucklescript$node jscomp<span class="hljs-regexp">/test/</span>exn_demo.js

<span class="hljs-regexp">/Users/</span>hongbozhang<span class="hljs-regexp">/git/</span>bucklescript<span class="hljs-regexp">/jscomp/</span>test/exn_demo.<span class="hljs-string">js:</span><span class="hljs-number">10</span>
      <span class="hljs-keyword">throw</span> {
      ^
{
<span class="hljs-symbol">  RE_EXN_ID:</span> <span class="hljs-string">'Exn_demo.My_exception/1'</span>,
<span class="hljs-symbol">  x:</span> <span class="hljs-number">10</span>,
<span class="hljs-symbol">  Error:</span> Error
      at loop (<span class="hljs-regexp">/Users/</span>hongbozhang<span class="hljs-regexp">/git/</span>bucklescript<span class="hljs-regexp">/jscomp/</span>test/exn_demo.<span class="hljs-string">js:</span><span class="hljs-number">13</span>:<span class="hljs-number">20</span>)
      at Object.&lt;anonymous&gt; (<span class="hljs-regexp">/Users/</span>hongbozhang<span class="hljs-regexp">/git/</span>bucklescript<span class="hljs-regexp">/jscomp/</span>test/exn_demo.<span class="hljs-string">js:</span><span class="hljs-number">21</span>:<span class="hljs-number">1</span>)
      at ...
}
</code></pre>
<p>That's basically it! Furthermore in this post, we want to give you some insights on how the data representation of exceptions looks like, and how it has been changed to expose useful stacktraces.</p>
<h2><a class="anchor" aria-hidden="true" id="why-it-is-tricky-to-preserve-stack-traces-in-reasonml-exceptions"></a><a href="#why-it-is-tricky-to-preserve-stack-traces-in-reasonml-exceptions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why it is tricky to preserve stack-traces in ReasonML exceptions</h2>
<p>Whenever you are using a Reason / OCaml exception (a so called &quot;native exception&quot;), you are actually using a data structure which is not the same as a JS runtime exception. That means that each exception representation invokes a different stacktrace handling mechanism:</p>
<p>In JS, the stacktrace is collected immediately when an Error object is created / thrown, while in native Reason / OCaml, such data is not attached to the exception object at all (you can't just access <code>e.stack</code> to retrieve the stacktrace). This is because collecting the stacktrace in a native environment highly depends on the runtime support (e.g. if a flag was provided to attach the stacktrace data).</p>
<p>Our goal was to provide a way to get the same stacktrace for native exceptions as you would with JS exceptions. This is all part of our on-going work to plan and implement the optimal encoding for all the different ReasonML data types for the JS runtime (just like with our previous changes to the <code>bool</code>, <code>unit</code> and <code>records</code> representation as well).</p>
<h2><a class="anchor" aria-hidden="true" id="whats-the-classical-reasonml-exception-encoding"></a><a href="#whats-the-classical-reasonml-exception-encoding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the classical ReasonML exception encoding?</h2>
<p>In ReasonML, an exception is basically structured data. Let's have a look at the two exception definitions below:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">exception</span> A <span class="hljs-keyword">of</span> { x : <span class="hljs-built_in">int</span> , y : <span class="hljs-built_in">string</span>}
<span class="hljs-keyword">exception</span> B
</code></pre>
<p><code>exception A</code> is encoded as an array of 3 slots. The first slot is a block by itself (called an <em>identity block</em>), while the second slot is for field x and the third slot for field y.</p>
<p><code>exception B</code> is just the identity block.</p>
<p>The identity block is an array of 2 slots. The first slot is a string like &quot;B&quot;, while the second slot is a unique integer.
In more detail, the native array will also have a magic tag 248 attached which is not relevant for our purposes though.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-the-new-exception-encoding"></a><a href="#whats-the-new-exception-encoding" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the new exception encoding?</h2>
<p>We had to simplify and unify the encoding for the different exception cases to make it possible to compile exceptions into an object instead of an array. Let's take a look at the two exception values below for example:</p>
<pre><code class="hljs css language-reasonml">A ({ x : <span class="hljs-number">1</span>, y : <span class="hljs-string">"x"</span>}
B
</code></pre>
<p>The two values will be compiled into</p>
<pre><code class="hljs css language-js">{<span class="hljs-attr">RE_EXN_ID</span> : <span class="hljs-string">"A/uuid"</span>, <span class="hljs-attr">x</span> : <span class="hljs-number">1</span>, <span class="hljs-attr">y</span> : <span class="hljs-string">"x"</span> }
{<span class="hljs-attr">RE_EXN_ID</span> : <span class="hljs-string">"B/uuid"</span>}
</code></pre>
<p>As you can see, all exceptions (no matter with or without payload) share the same encoding.</p>
<p>What will happen when you raise an exception?</p>
<pre><code class="hljs css language-reasonml">raise (A {x : <span class="hljs-number">1</span> , y : <span class="hljs-string">"x"</span>})
</code></pre>
<p>It generates following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">throw</span> {<span class="hljs-attr">RE_EXN_ID</span>: <span class="hljs-string">"A/uuid"</span>, <span class="hljs-attr">x</span> : <span class="hljs-number">1</span> , <span class="hljs-attr">y</span> : <span class="hljs-string">"x"</span>, <span class="hljs-attr">Error</span> : <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span> ()}
</code></pre>
<p>The output above shows that we are now able to attach the stacktrace as an <code>Error</code> attribute very easily, since every exception is now an object instead of an array. Really cool!</p>
<p>It's important to note that a stacktrace will only be attached <em>when you raise an exception</em>. In other words, the stacktrace will not be attached just by creating an exception (which is different to JS'es <code>new Error()</code> behavior).</p>
<h2><a class="anchor" aria-hidden="true" id="what-does-that-mean-for-js-interop"></a><a href="#what-does-that-mean-for-js-interop" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What does that mean for JS interop?</h2>
<p>Note that in the JS world, users can pretty much throw any value they want. It is even totally valid to <code>throw undefined</code>. In ReasonML, when you try to catch an exception, the compiler will convert any arbitrary value to a ReasonML exception behind the scene:</p>
<ul>
<li>If it is already a ReasonML exception, then the conversion will be a no-op (no runtime cost</li>
<li>Otherwise it will be wrapped as a <code>Js.Exn.Error obj</code></li>
</ul>
<p>Here is an example on how you'd access the exception value within a Reason <code>try</code> expression:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">try</span> (some<span class="hljs-constructor">JSFunctionThrowing()</span>) {
<span class="hljs-pattern-match">| <span class="hljs-constructor">Not_found</span> =&gt;</span> ..  <span class="hljs-comment">// catch  reasonml exception 1 </span>
<span class="hljs-pattern-match">| <span class="hljs-constructor">Invalid_argument</span> =&gt;</span>  <span class="hljs-comment">// catch  reasonml exception 2</span>
<span class="hljs-pattern-match">| <span class="hljs-constructor">Js</span>.<span class="hljs-constructor">Exn</span>.<span class="hljs-constructor">Error</span> (obj) =&gt;</span><span class="hljs-operator"> ... </span><span class="hljs-comment">// catch js exception</span>
}
</code></pre>
<p>The <code>obj</code> value in the <code>Js.Exn.Error</code> branch is an opaque type to maintain type soundness, so if you need to interact with this value, you need to classify it into a concrete type first.</p>
<h2><a class="anchor" aria-hidden="true" id="caveat"></a><a href="#caveat" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Caveat</h2>
<ul>
<li><p>Please note that it's not allowed to rely on the key name of <code>RE_EXN_ID</code>. It's an implementation detail which will probably be changed into a symbol in the future.</p></li>
<li><p>Don't over-use exeptions, remember exception should only be used in exceptional cases like division by zero. Whenever you  try to express erroneous results, use the <code>result</code> or <code>option</code> type instead.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="bonus"></a><a href="#bonus" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bonus</h2>
<p>Now with our new exception encoding in place, a hidden feature called <a href="https://caml.inria.fr/pub/docs/manual-ocaml/extensiblevariants.html">extensible variant</a> suddenly got way more interesting as well. Practically speaking, native exceptions are actually a special form of an extensible variant, so both are benefiting from the same representation changes!</p>
<p>Happy hacking and we would like your feedback!</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/04/13/release-7-3">What&#x27;s new in release 7.3</a></h1><p class="post-meta">April 13, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform@7.3</code> is available for testing, you can try it with <code>npm install bs-platform@7.3.1</code>.</p>
<p>For those unfamiliar with bs-platform, it is the platform for compiling <a href="https://reasonml.github.io/">ReasonML</a> and <a href="https://ocaml.org/">OCaml</a> to fast and readable JavaScript.</p>
<p>This is a major release with some highlighted features as below:</p>
<h2><a class="anchor" aria-hidden="true" id="generalized-uncurry-calling-convention-support"></a><a href="#generalized-uncurry-calling-convention-support" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generalized uncurry calling convention support</h2>
<p>You can use an uncurried function as conveniently as a curried one now, this is an exciting change that we wrote a <a href="https://bucklescript.github.io/blog/2020/03/26/generalize-uncurry">separate post</a> for details.</p>
<p>For uncurried support, we also fixed a long standing <a href="https://github.com/BuckleScript/bucklescript/issues/4274">issue</a> so that type inference follows naturally using the new encoding.</p>
<pre><code class="hljs css language-reasonml">bar 
 -&gt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Belt</span>.</span><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>map<span class="hljs-constructor">U((.<span class="hljs-params">b</span>)</span>=&gt;b.foo <span class="hljs-comment">/*no type annotation needed */</span>)
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="unit-value-is-compiled-into-undefined"></a><a href="#unit-value-is-compiled-into-undefined" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>unit</code> value is compiled into <code>undefined</code></h2>
<p>In ReasonML, when a function does not return any meaningful value, it returns a value that is <code>()</code> of type <code>unit</code>. In native backend, the dummy value <code>()</code> is compiled into a const zero. We used to inherit this in JS backend as well. However, this is a semantics mismatch since in JS, if the function does not return anything, it defaults to <code>undefined</code>. In this release, we make it more consistent with JS: compiling <code>()</code> into <code>undefined</code>. Since in JS, <code>return undefined</code> can be ignored in tail position, this leads to some other nice enhancement.</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> log =<span class="hljs-function"> <span class="hljs-params">x</span> =&gt;</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>log(x)
</code></pre>
<p>The generated code used to be</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">x</span>)</span>{
    <span class="hljs-built_in">console</span>.log(x);
    <span class="hljs-keyword">return</span> <span class="hljs-comment">/* () */</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>It's now</p>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">x</span>)</span>{
    <span class="hljs-built_in">console</span>.log(x)
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="various-improvements-in-code-generation"></a><a href="#various-improvements-in-code-generation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Various improvements in code generation</h2>
<p>We have increased the readability of the generated code in several common places, we believe that we reached <em>an important milestone</em> that if you write code using features that have counterparts in JS, the generated code is readable. This is not a small achievement given that quite a lot of the compiler code base is shared between native backend and JS backend.</p>
<p>There are some features that are not available in JS, for example, complex pattern matches, the readability of those pieces of generated code will continue being improved.</p>
<p>Take several enhancement below as  examples:</p>
<ul>
<li>meaningful pattern match variable names</li>
</ul>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> popUndefined =<span class="hljs-function"> <span class="hljs-params">s</span> =&gt;</span>
  switch (s.root) {
  <span class="hljs-pattern-match">| <span class="hljs-constructor">None</span> =&gt;</span> <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span></span>undefined
  <span class="hljs-pattern-match">| <span class="hljs-constructor">Some(<span class="hljs-params">x</span>)</span> =&gt;</span>
    s.root = x.tail;
    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Js</span>.</span><span class="hljs-module"><span class="hljs-identifier">Undefined</span>.</span></span>return(x.head);
  };
</code></pre>
<pre><code class="hljs css language-diff">function popUndefined(s) {
<span class="hljs-deletion">-  var match = s.root;</span>
<span class="hljs-deletion">-  if (match !== null) {</span>
<span class="hljs-deletion">-    s.root = match.tail;</span>
<span class="hljs-deletion">-    return match.head;</span>
<span class="hljs-addition">+  var x = s.root;</span>
<span class="hljs-addition">+  if (x !== undefined) {</span>
<span class="hljs-addition">+    s.root = x.tail;</span>
<span class="hljs-addition">+    return x.head;</span>
   }
   
 }
</code></pre>
<p>When pattern match against a compounded expression, the compiler used to use a temporary name <code>match</code>, now we employ better heuristics to generate meaningful names for such temporary variables.</p>
<ul>
<li>Eliminate intermediate variable names when inlining</li>
</ul>
<pre><code class="hljs css language-diff"> function everyU(arr, b) {
   var len = arr.length;
<span class="hljs-deletion">-  var arr$1 = arr;</span>
   var _i = 0;
<span class="hljs-deletion">-  var b$1 = b;</span>
<span class="hljs-deletion">-  var len$1 = len;</span>
   while(true) {
     var i = _i;
<span class="hljs-deletion">-    if (i === len$1) {</span>
<span class="hljs-addition">+    if (i === len) {</span>
       return true;
<span class="hljs-deletion">-    } else if (b$1(arr$1[i])) {</span>
<span class="hljs-deletion">-      _i = i + 1 | 0;</span>
<span class="hljs-deletion">-      continue ;</span>
<span class="hljs-deletion">-    } else {</span>
<span class="hljs-addition">+    }</span>
<span class="hljs-addition">+    if (!b(arr[i])) {</span>
       return false;
     }
<span class="hljs-addition">+    _i = i + 1 | 0;</span>
<span class="hljs-addition">+    continue ;</span>
   };
 }
</code></pre>
<p>The above diff is the generated code for <code>Belt.Array.everyU</code>, the intermediate variables were introduced when inlining an auxiliary function, such duplication were removed in this release.</p>
<ul>
<li>Flatten if/else branch making use of JS's <code>early return</code> idiom</li>
</ul>
<p>Take the same diff from above, you will notice that the second <code>else</code> following <code>if(..) continue</code> is removed.</p>
<p>Below are similar diffs benefiting from such enhancement:</p>
<pre><code class="hljs css language-diff"> function has(h, key) {
@@ -133,21 +123,18 @@ function has(h, key) {
   var nid = Caml_hash_primitive.caml_hash_final_mix(Caml_hash_primitive.caml_hash_mix_string(0, key)) &amp; (h_buckets.length - 1 | 0);
   var bucket = h_buckets[nid];
   if (bucket !== undefined) {
<span class="hljs-deletion">-    var key$1 = key;</span>
     var _cell = bucket;
     while(true) {
       var cell = _cell;
<span class="hljs-deletion">-      if (cell.key === key$1) {</span>
<span class="hljs-addition">+      if (cell.key === key) {</span>
         return true;
<span class="hljs-deletion">-      } else {</span>
<span class="hljs-deletion">-        var match = cell.next;</span>
<span class="hljs-deletion">-        if (match !== undefined) {</span>
<span class="hljs-deletion">-          _cell = match;</span>
<span class="hljs-deletion">-          continue ;</span>
<span class="hljs-deletion">-        } else {</span>
<span class="hljs-deletion">-          return false;</span>
<span class="hljs-deletion">-        }</span>
       }
<span class="hljs-addition">+      var nextCell = cell.next;</span>
<span class="hljs-addition">+      if (nextCell === undefined) {</span>
<span class="hljs-addition">+        return false;</span>
<span class="hljs-addition">+      }</span>
<span class="hljs-addition">+      _cell = nextCell;</span>
<span class="hljs-addition">+      continue ;</span>
     };
   } else {
     return false;
@@ -155,17 +142,17 @@ function has(h, key) {
 }
</code></pre>
<pre><code class="hljs css language-diff"><span class="hljs-comment">--- a/lib/js/belt_List.js</span>
<span class="hljs-comment">+++ b/lib/js/belt_List.js</span>
@@ -15,9 +15,8 @@ function head(x) {
 function headExn(x) {
   if (x) {
     return x[0];
<span class="hljs-deletion">-  } else {</span>
<span class="hljs-deletion">-    throw new Error("headExn");</span>
   }
<span class="hljs-addition">+  throw new Error("headExn");</span>
 }
 
</code></pre>
<ul>
<li>For loop minor-enhancement</li>
</ul>
<pre><code class="hljs css language-diff"> function shuffleInPlace(xs) {
   var len = xs.length;
<span class="hljs-deletion">-  for(var i = 0 ,i_finish = len - 1 | 0; i &lt;= i_finish; ++i){</span>
<span class="hljs-addition">+  for(var i = 0; i &lt; len; ++i){</span>
     swapUnsafe(xs, i, Js_math.random_int(i, len));
   }
<span class="hljs-deletion">-  return /* () */0;</span>
<span class="hljs-addition">+  </span>
 }
</code></pre>
<p>Reason's <code>for .. in</code> only provide closed interval iterating, so it is quite common to write
<code>for (i in 0 to Array.length(x) - 1) { .. }</code>, we did the tweaking above to make the generated code more readable.</p>
<p>A full list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#73">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#73</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/03/26/generalize-uncurry">Generalized uncurry support in BuckleScript 7.3</a></h1><p class="post-meta">March 26, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://github.com/facebook/reason">ReasonML</a> is a <a href="https://en.wikipedia.org/wiki/Currying">curried</a> language, while Js is an uncurried language. When compiling ReasonML into Js, there's lots of headache due to the semantics mismatch.</p>
<p>After several years of research and development, we reach an ideal situation in the next release: adding a lightweight uncurried calling convention to ReasonML.</p>
<h2><a class="anchor" aria-hidden="true" id="why-we-need-native-uncurried-calling-convention"></a><a href="#why-we-need-native-uncurried-calling-convention" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Why we need native uncurried calling convention</h2>
<ul>
<li><p>The curried call is inherently slower than the uncurried call.</p>
<p>A native implementation of curried call like <a href="https://www.purescript.org/">purescript</a> does will generate very slow code:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">let</span> curriedFunction = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">z</span> =&gt;</span> x + y +z ;
<span class="hljs-keyword">let</span> curriedApply = curriedFunction(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">// memory allocation triggered</span>
</code></pre>
<p>BuckleScript does tons of optimizations and very aggressive arity inference so that the curried function is compiled into a multiple-arity function, and when the application is supplied with the exact arguments -- which is true in most cases, it is applied like normal functions.</p>
<p>However, such optimization does not apply to high order functions:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> highOrder =<span class="hljs-function"> (<span class="hljs-params">f</span>,<span class="hljs-params">a</span>,<span class="hljs-params">b</span>)=&gt;</span> f (a, b) 
<span class="hljs-comment">// can not infer the arity of `f` since we know</span>
<span class="hljs-comment">// nothing about the arity of `f`, unless</span>
<span class="hljs-comment">// we do the whole program optimization</span>
</code></pre>
<p>In cases where arity inference does not help, the arity guessing has to be delayed into the runtime.</p></li>
<li><p>Bindings to JS world</p>
<p>When we create bindings for high order functions in the JS world, we would like to have native uncurried functions which behave the same as JS world -- no semantics mismatch.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="generalized-uncurried-calling-convention-in-this-release"></a><a href="#generalized-uncurried-calling-convention-in-this-release" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generalized uncurried calling convention in this release</h2>
<p>Before release 7.3, we had introduced uncurried calling convention, however, it has serious limitations -- uncurried functions can not be polymorphic, it does not support labels, the error
message leaks the underlying encoding -- now all those limitations are gone!</p>
<p>Previously</p>
<p><img src="/img/poly-error.png"></p>
<p><img src="/img/label-error.png"></p>
<p><img src="/img/recursive-error.png" ></p>
<p>The error messages above are cryptic and hard to understand. And the limitation of not supporting recursive functions make uncurried support pretty weak.</p>
<p>Now those limitations are all gone, you can have polymorphic uncurried recursive functions and it support labels.</p>
<p><img src="/img/uncurry-label.png"></p>
<p><img src="/img/recursive.png"></p>
<p>The error message is  also enhanced significantly</p>
<ul>
<li><p>When the uncurried function is used in curried</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> add =<span class="hljs-function"> (. <span class="hljs-params">x</span>, <span class="hljs-params">y</span> ) =&gt;</span> x + y;

<span class="hljs-keyword">let</span> u = add (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>The old error message:</p>
<pre><code class="hljs">Error: This expression has<span class="hljs-built_in"> type </span>(. int, int) =&gt; int
    This is <span class="hljs-keyword">not</span> a function; it cannot be applied.
</code></pre>
<p>The new error message</p>
<pre><code class="hljs"><span class="hljs-keyword">Error: </span>This function has uncurried type, it needs to be applied in ucurried style
</code></pre></li>
<li><p>When the curried function is used in the uncurried context</p>
<pre><code class="hljs css language-reasonml">
<span class="hljs-keyword">let</span> add =<span class="hljs-function"> ( <span class="hljs-params">x</span>, <span class="hljs-params">y</span> ) =&gt;</span> x + y;

<span class="hljs-keyword">let</span> u = add (.<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)
</code></pre>
<p>The old error message:</p>
<pre><code class="hljs">Error: This expression has<span class="hljs-built_in"> type </span>(int, int) =&gt; int
    but an expression was expected of<span class="hljs-built_in"> type </span>(. <span class="hljs-string">'a, '</span>b) =&gt; <span class="hljs-string">'c
</span></code></pre>
<p>The new error message:</p>
<pre><code class="hljs"><span class="hljs-keyword">Error: </span>This function is a curried function where an uncurried function is expected
</code></pre></li>
<li><p>When arity mismatch</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">let</span> add =<span class="hljs-function"> (. <span class="hljs-params">x</span>, <span class="hljs-params">y</span> ) =&gt;</span> x + y;

<span class="hljs-keyword">let</span> u = add (.<span class="hljs-number">1</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
</code></pre>
<p>The old message:</p>
<pre><code class="hljs">Error: This expression has<span class="hljs-built_in"> type </span>(. int, int) =&gt; int
    but an expression was expected of<span class="hljs-built_in"> type </span>(. <span class="hljs-string">'a, '</span>b, <span class="hljs-string">'c) =&gt; '</span>d
    These two variant types have <span class="hljs-literal">no</span> intersection
</code></pre>
<p>The new message:</p>
<pre><code class="hljs"><span class="hljs-keyword">Error: </span>This function has arity2 but was expected arity3
</code></pre></li>
</ul>
<p>Note the generalized uncurry support also applies to objects, so that you can use <code>obj##meth (~label1=a,~label2=b)</code>.</p>
<p>The only thing where the uncurried call is not supported is optional arguments, if users are mostly targeting JS runtime, we suggest you can try uncurry by default and would like to hear your feedback!</p>
<p>You can already test it today by <code>npm install bs-platform@7.3.0-dev.1</code> (Windows support will be coming soon).</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/03/12/release-7-2">Announcing bs-platform  7.2</a></h1><p class="post-meta">March 12, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>Today we are proud to release <code>bs-platform 7.2</code>!</p>
<p>For those unfamiliar with bs-platform, it is the platform for compiling <a href="https://reasonml.github.io/">ReasonML</a> and <a href="https://ocaml.org/">OCaml</a> to fast and readable JavaScript.</p>
<p>You can try it with <code>npm i bs-platform</code>!</p>
<p>This is a major release with some highlighted features as below:</p>
<h2><a class="anchor" aria-hidden="true" id="in-memory-loading-stdlib"></a><a href="#in-memory-loading-stdlib" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>In memory loading stdlib</h2>
<p>Since this release, the binary artifacts generated by the stdlib are loaded from memory instead of an external file systems, which means much faster compilation and installation.</p>
<p>Previously we recommended installing <code>bs-platform</code> globally to save on installation time.</p>
<p>However, with this release the installation is so fast that  we recommend installing it locally instead - per project - instead, as there's no additional cost, and it provides better isolation.</p>
<p>You can use it with a nice tool called <a href="https://www.npmjs.com/package/npx">npx</a>, for example, <code>npx bsb</code>.</p>
<p>The installation is also compatible with <code>--ignore-scripts</code> for major platforms (see <a href="https://youtu.be/okrB3aJtUaw?t=921">Richard Feldman's talk</a> on the security implications), and is more stable with <a href="https://github.com/yarnpkg/yarn">yarn</a></p>
<p>More technical details can be found in this <a href="https://bucklescript.github.io/blog/2020/02/20/loading-stdlib-in-memory">post</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="let-private"></a><a href="#let-private" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>let %private</h2>
<p>In OCaml's module system, everything is public by default, the only way to hide some values is by providing a separate signature to list public fields and their types:</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">module</span> A : { <span class="hljs-keyword">let</span> b : <span class="hljs-built_in">int</span>} = {
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">3</span> ;
    <span class="hljs-keyword">let</span> b = <span class="hljs-number">4</span> ; 
}
</code></pre>
<p><code>let</code> <code>%private</code> gives you an option to mark private fields directly</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">module</span> A  = {
    <span class="hljs-keyword">let</span>%<span class="hljs-keyword">private</span> a  = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">let</span> b  = <span class="hljs-number">4</span>;
}
</code></pre>
<p><code>let%private</code> also applies to file level modules, so in some cases, user does not need to provide a separate interface file just to hide some particular values.</p>
<p>Note interface files are still recommended as a general best practice since they give you better separate compilation units and also they're better for documentation. Still, <code>let%private</code> is useful in the following scenarios:</p>
<ul>
<li><p>Code generators. Some code generators want to hide some values but it is sometimes very hard or time consuming for code generators to synthesize the types for public fields.</p></li>
<li><p>Quick prototyping. During prototyping, we still want to hide some values, but the interface file is not stable yet, <code>let%private</code> provide you such convenience.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="int64-performance-optimization"></a><a href="#int64-performance-optimization" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Int64 performance optimization</h2>
<p>We received feedback from some users that various Int64 operations became bottlenecks in their code performance, in particular <code>Int64.to_string</code>.</p>
<p>We responded to this, and after some hard work - but <em>without</em> changing the underlying representation - our <code>Int64.to_string</code> is even faster than <code>bigint</code> for common inputs.</p>
<p>A micro-benchmark for comparison:</p>
<pre><code class="hljs"><span class="hljs-string">running</span> <span class="hljs-string">on</span> <span class="hljs-number">7.1</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">367.</span><span class="hljs-string">788ms</span> <span class="hljs-comment"># super positive number </span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">140.</span><span class="hljs-string">451ms</span> <span class="hljs-comment"># median number</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">375.</span><span class="hljs-string">471ms</span> <span class="hljs-comment"># super negative number</span>

<span class="hljs-string">bigint</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">25.</span><span class="hljs-string">151ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">12.</span><span class="hljs-string">278ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">21.</span><span class="hljs-string">011ms</span>

<span class="hljs-string">latest</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">43.</span><span class="hljs-string">228ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">5.</span><span class="hljs-string">764ms</span>
<span class="hljs-attr">Int64.to_string:</span> <span class="hljs-number">43.</span><span class="hljs-string">270ms</span>
</code></pre>
<p>We also apply such optimizations to other Int64 operations.</p>
<p>Note that Int64 is implemented in OCaml itself without any raw JavaScript. This is case compelling hints that our optimizing compiler not only provides expressivity and type-safe guarantees, but also empowers users to write maintainable, <em>efficient</em> code.</p>
<h2><a class="anchor" aria-hidden="true" id="file-level-compilation-flags"></a><a href="#file-level-compilation-flags" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>File level compilation flags</h2>
<p>In this release, we also provide a handy flag to allow users to override some configurations at the file level.</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-literal">[@<span class="hljs-identifier">bs</span>.<span class="hljs-identifier">config</span> {<span class="hljs-identifier">flags</span>: [|"-<span class="hljs-identifier">w</span>", "<span class="hljs-identifier">a</span>", "-<span class="hljs-identifier">bs</span>-<span class="hljs-identifier">no</span>-<span class="hljs-identifier">bin</span>-<span class="hljs-identifier">annot</span>"|]</span>}]; <span class="hljs-comment">// toplevel attributes</span>
</code></pre>
<p>A full list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#72">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#72</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/20/loading-stdlib-in-memory">Loading stdlib from memory</a></h1><p class="post-meta">February 20, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><h2><a class="anchor" aria-hidden="true" id="loading-stdlib-from-memory"></a><a href="#loading-stdlib-from-memory" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Loading stdlib from memory</h2>
<!-- Do you mean "external files" instead of "external file system"? In Linux world, a file system is means something like EXT4 or btrfs -->
In the next release, we are going to load stdlib from memory instead of from external files, which will make the BuckleScript toolchain more accessible and performant.
<p>You can try it via <code>npm i bs-platform@7.2.0-dev.4</code></p>
<h2><a class="anchor" aria-hidden="true" id="how-does-it-work"></a><a href="#how-does-it-work" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How does it work</h2>
<p>When the compiler compiles a module <code>test.ml</code>, the module <code>Test</code> will import some modules from stdlib. This is inevitable since even basic operators in BuckleScript, for example <code>(+)</code>, are defined in the Pervasives module, which is part of the stdlib.</p>
<p>Traditionally, the compiler will consult <code>Pervasives.cmi</code>, which is a binary artifact describing the interface of the Pervasives module and <code>Pervasives.cmj</code>, which is a binary artifact describing the implementation of the Pervasives module. <code>Pervasives.cm[ij]</code> and other modules in stdlib are shipped together with the compiler.</p>
<p>This traditional mode has some consequences:</p>
<ul>
<li>The compiler is not stand-alone and relocatable. Even if we have the compiler prebuilt for different platforms, we still have to compile stdlib post-installation. <code>postinstall</code> is supported by npm, but it has <a href="https://github.com/BuckleScript/bucklescript/issues/3213">various</a> <a href="https://github.com/BuckleScript/bucklescript/issues/2799">issues</a> <a href="https://github.com/BuckleScript/bucklescript/issues/3254">against</a> yarn.</li>
</ul>
<!-- I made my best guess as to what you mean by "they" in "However, they are still needed" (and tried to eliminate the repetition of the word "needed" -->
- It's hard to split the compiler from the generated stdlib JS artifacts. When a BuckleScript user deploys apps depending on BuckleScript, in theory, the app only needs to deploy those generated JS artifacts; the native binary is not needed in production. However, the artifacts are still loaded since they are bundled together. Allowing easy delivery of compiled code is one of the community’s most desired [feature requests](https://github.com/BuckleScript/bucklescript/issues/2772).
<p>In this release, we solve the problem by embedding the binary artifacts into the compiler directly and loading it on demand.</p>
<p>To make this possible, we try to make the binary data platform agnostic and as compact as possible to avoid size bloating. The entrance of loading cmi/cmj has to be adapted to this new way.</p>
<p>So whenever the compiler tries to load a module from stdlib, it will consult a lazy data structure in the compiler itself instead of consulting an external file system.</p>
<h2><a class="anchor" aria-hidden="true" id="whats-the-benefit"></a><a href="#whats-the-benefit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What's the benefit?</h2>
<ul>
<li><p>More accessiblity.</p>
  <!-- In the phrase "we can make it installable", what does "it" refer to? -->
  Package installation now becomes downloading for prebuilt platforms. In the future, we can make it installable from a system package manager as well. The subtle interaction with [yarn reinstall](https://github.com/BuckleScript/bucklescript/issues/2799) is also solved once and for all.
</li>
</ul>
<ul>
<li><p>Easy separation between compiler and JS artifacts</p>
<p><!-- instead of "between compiler and stdlib version schemes", perhaps say "for aligning compiler and stdlib version schemes" -->
The compiler is just one relocatable file. This makes the separation between the compiler and generated JS artifacts easier. The remaining work is mostly to design a convention between compiler and stdlib version schemes.</p></li>
<li><p>Yes, better compile performance</p>
<p>A large set of files is not loaded from the file system but rather from memory now!</p></li>
<li><p>Fast installation and reinstallation.</p>
<p>Depending on your network speed, the installation is reduced from 15 seconds to 3 seconds. Reinstallation is almost a no-op now.</p></li>
</ul>
<!-- TODO: collect data points later -->
<ul>
<li><p>JS playground is easier to build</p>
<p><!-- I'm not sure what you mean by "compiling a single file to a string" -->
We translate the compiler into JS so that developers can play with it in the browser.  To make this happen, we used to fake the IO system; this not needed any more since no IO happens when compiling a single file to a string.</p></li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="some-internal-changes"></a><a href="#some-internal-changes" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Some internal changes</h2>
<p>To make this happen, the layout of binaries has been changed to the following structure. It is <strong>not recommended</strong> that users depend on the layout, but <a href="https://github.com/BuckleScript/bucklescript/pull/4170#issuecomment-586959464">it happens</a>. Here is the new layout:</p>
<pre><code class="hljs">
|<span class="hljs-string">-- bsb // node wrapper of bsb.exe
</span>|<span class="hljs-string">-- bsc // node wrapper of bsc.exe
</span>|
|<span class="hljs-string">-- win32
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsb.exe
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsc.exe 
</span>|
|<span class="hljs-string">---darwin
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsb.exe
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsc.exe
</span>|
|<span class="hljs-string">---linux
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsb.exe
</span>|<span class="hljs-string">     </span>|<span class="hljs-string">-- bsc.exe

</span></code></pre>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/07/union-types-in-bucklescript">Union types in BuckleScript</a></h1><p class="post-meta">February 7, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#union-types">Union types</a></p>
<p>Union types describe a value that can be one of several types. In JS, it is common to use the vertical bar (|) to separate each type, so <code>number | string | boolean</code>  is the type of a value that can be a number, a string, or a boolean.</p>
<p>Following <a href="https://bucklescript.github.io/blog/2019/12/20/release-7-02">the last post</a> since the introduction of unboxed attributes in <code>7.1.0</code>, we can create such types as follows:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> t = 
    | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span>  -&gt; t 
[@@unboxed]    
<span class="hljs-keyword">let</span> a (v : a) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> b (v : b) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> c (v : c) = <span class="hljs-type">Any</span> v
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t =
  | <span class="hljs-constructor">Any</span>('a): t;
<span class="hljs-keyword">let</span> a = (v: a) =&gt; <span class="hljs-constructor">Any</span>(v);
<span class="hljs-keyword">let</span> b = (v: b) =&gt; <span class="hljs-constructor">Any</span>(v);
<span class="hljs-keyword">let</span> c = (v: c) =&gt; <span class="hljs-constructor">Any</span>(v);
</code></pre>
<p>Note: due to the <code>unboxed</code> attribute, <code>Any a</code> shares the same runtime representation as <code>a</code>; however, we need to make sure that user can only construct values of type <code>a</code>, <code>b</code> , or <code>c</code> into type <code>t</code>. By making use of the module system, we can achieve this:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">A_b_c</span> : <span class="hljs-keyword">sig</span> 
  <span class="hljs-keyword">type</span> t 
  <span class="hljs-keyword">val</span> a : a -&gt; t 
  <span class="hljs-keyword">val</span> b : b -&gt; t 
  <span class="hljs-keyword">val</span> c : c -&gt; t   
<span class="hljs-keyword">end</span>= <span class="hljs-keyword">struct</span> 
<span class="hljs-keyword">type</span> t = 
    | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span>  -&gt; t 
[@@unboxed]    
<span class="hljs-keyword">let</span> a (v : a) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> b (v : b) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">let</span> c (v : c) = <span class="hljs-type">Any</span> v
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">A_b_c</span>: {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> a: a =&gt; t;
  <span class="hljs-keyword">let</span> b: b =&gt; t;
  <span class="hljs-keyword">let</span> c: c =&gt; t;
} = {
  <span class="hljs-attribute">[@unboxed]</span>
  <span class="hljs-keyword">type</span> t =
    | <span class="hljs-constructor">Any</span>('a): t;  
  <span class="hljs-keyword">let</span> a = (v: a) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> b = (v: b) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> c = (v: c) =&gt; <span class="hljs-constructor">Any</span>(v);
};
</code></pre>
<!-- Union types are useful for modeling situations when values can overlap in the types they can take on.  -->
What happens when we need to know specifically whether we have a value of type `a`? This is a case by case issue; it depends on whether there are some intersections in the runtime encoding of `a`, `b` or `c`. For some primitive types, it is easy enough to use `Js.typeof` to tell the difference between, e.g, `number` and `string`. 
<p>Like <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-guards-and-differentiating-types">type guards in typescript</a>, we have to trust the user knowledge to differentiate between union types. However, such user level knowledge is isolated in a single module so that we can reason about its correctness locally.</p>
<p>Let's have a simple example, <code>number_or_string</code> first:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">Number_or_string</span> : <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> t 
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">Number</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> 
        | <span class="hljs-type">String</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span>
    <span class="hljs-keyword">val</span> number : <span class="hljs-built_in">float</span> -&gt; t 
    <span class="hljs-keyword">val</span> <span class="hljs-built_in">string</span> : <span class="hljs-built_in">string</span> -&gt; t 
    <span class="hljs-keyword">val</span> classify : t -&gt; case             
<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span> 
    <span class="hljs-keyword">type</span> t = 
        | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t 
    [@@unboxed]     
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">Number</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">float</span> 
        | <span class="hljs-type">String</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">string</span>
    <span class="hljs-keyword">let</span> number (v : <span class="hljs-built_in">float</span>) = <span class="hljs-type">Any</span> v 
    <span class="hljs-keyword">let</span> <span class="hljs-built_in">string</span> (v : <span class="hljs-built_in">string</span>) = <span class="hljs-type">Any</span> v     
    <span class="hljs-keyword">let</span> classify (<span class="hljs-type">Any</span> v : t) : case = 
        <span class="hljs-keyword">if</span> <span class="hljs-type">Js</span>.typeof v = <span class="hljs-string">"number"</span> <span class="hljs-keyword">then</span> <span class="hljs-type">Number</span> (<span class="hljs-type">Obj</span>.magic v  : <span class="hljs-built_in">float</span>)
        <span class="hljs-keyword">else</span> <span class="hljs-type">String</span> (<span class="hljs-type">Obj</span>.magic v : <span class="hljs-built_in">string</span>)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">Number_or_string</span>: {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">Number</span>(float)
    | <span class="hljs-constructor">String</span>(string);
  <span class="hljs-keyword">let</span> number: float =&gt; t;
  <span class="hljs-keyword">let</span> string: string =&gt; t;
  <span class="hljs-keyword">let</span> classify: t =&gt; case;
} = {
  <span class="hljs-attribute">[@unboxed]</span>
  <span class="hljs-keyword">type</span> t =
    | <span class="hljs-constructor">Any</span>('a): t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">Number</span>(float)
    | <span class="hljs-constructor">String</span>(string);
  <span class="hljs-keyword">let</span> number = (v: float) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> string = (v: string) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> classify = (<span class="hljs-constructor">Any</span>(v): t): case =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-module-identifier">Js</span>.typeof(v) <span class="hljs-operator">==</span> <span class="hljs-string">"number"</span>) {
      <span class="hljs-constructor">Number</span>(<span class="hljs-module-identifier">Obj</span>.magic(v): float);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-constructor">String</span>(<span class="hljs-module-identifier">Obj</span>.magic(v): string);
    };
};
</code></pre>
<p>Note that here we use <code>Obj.magic</code> to do an unsafe type cast which relies on <code>Js.typeof</code>. In practice, people may use <code>instanceof</code>; the following is an imaginary example:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">module</span> <span class="hljs-type">A_or_b</span> : <span class="hljs-keyword">sig</span> 
    <span class="hljs-keyword">type</span> t 
    <span class="hljs-keyword">val</span> a : a -&gt; t 
    <span class="hljs-keyword">val</span> b : b -&gt; t 
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">A</span> <span class="hljs-keyword">of</span> a 
        | <span class="hljs-type">B</span> <span class="hljs-keyword">of</span> b 
    <span class="hljs-keyword">val</span> classify : t -&gt; case
<span class="hljs-keyword">end</span> = <span class="hljs-keyword">struct</span>
    <span class="hljs-keyword">type</span> t = 
        | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t
    [@@unboxed]   
    <span class="hljs-keyword">type</span> case = 
        | <span class="hljs-type">A</span> <span class="hljs-keyword">of</span> a 
        | <span class="hljs-type">B</span> <span class="hljs-keyword">of</span> b 
    <span class="hljs-keyword">let</span> a (v : a) = <span class="hljs-type">Any</span> v 
    <span class="hljs-keyword">let</span> b = (v : b) = <span class="hljs-type">Any</span> v
    <span class="hljs-keyword">let</span> classify ( <span class="hljs-type">Any</span> v : t)  = 
        <span class="hljs-keyword">if</span> [%raw{|<span class="hljs-keyword">function</span> (a) { return  a instanceof globalThis.<span class="hljs-type">A</span>}|}] v <span class="hljs-keyword">then</span> <span class="hljs-type">A</span> (<span class="hljs-type">Obj</span>.magic v : a)
        <span class="hljs-keyword">else</span> <span class="hljs-type">B</span> (<span class="hljs-type">Obj</span>.magic b)
<span class="hljs-keyword">end</span>
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">module</span> <span class="hljs-module-identifier">A_or_b</span>: {
  <span class="hljs-keyword">type</span> t;
  <span class="hljs-keyword">let</span> a: a =&gt; t;
  <span class="hljs-keyword">let</span> b: b =&gt; t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">A</span>(a)
    | <span class="hljs-constructor">B</span>(b);
  <span class="hljs-keyword">let</span> classify: t =&gt; case;
} = {
  <span class="hljs-attribute">[@unboxed]</span>
  <span class="hljs-keyword">type</span> t =
    | <span class="hljs-constructor">Any</span>('a): t;
  <span class="hljs-keyword">type</span> case =
    | <span class="hljs-constructor">A</span>(a)
    | <span class="hljs-constructor">B</span>(b);
  <span class="hljs-keyword">let</span> a = (v: a) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> b = (v: b) =&gt; <span class="hljs-constructor">Any</span>(v);
  <span class="hljs-keyword">let</span> classify = (<span class="hljs-constructor">Any</span> (v): t) =&gt;
    <span class="hljs-keyword">if</span> (<span class="hljs-attribute">[%raw {|function (a) { return  a instanceof globalThis.A}|}]</span>(v)) {
      <span class="hljs-constructor">A</span>(<span class="hljs-module-identifier">Obj</span>.magic(v): a);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-constructor">B</span>(<span class="hljs-module-identifier">Obj</span>.magic(b));
    };
};
</code></pre>
<p>Here we suppose <code>a</code> is of JS class type <code>A</code>, and we use <code>instanceof</code> to test it. Note we use some <code>unsafe</code> code locally, but as long as such code is carefully reviewed, it has a safe boundary at the module level.</p>
<p>To conclude: thanks to <code>unboxed</code> attributes and the module language, we introduce a systematic way to convert values from <code>union types</code> (untagged union types) to <code>algebraic data types</code> (tagged union types). This sort of conversion relies on user level knowledge and has to be reviewed carefully. For some cases where <code>classify</code> is not needed, it can be done in a completely type safe way.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2020/02/04/release-7-1-0">bs-platform release 7.1.0</a></h1><p class="post-meta">February 4, 2020</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><code>bs-platform@7.1.0</code> is a major release. You can try it with <code>npm i -g bs-platform</code>!
(If you have permission issues, try <code>sudo npm i --unsafe-perm -g bs-platform</code>)</p>
<p>It was called 7.0.2 but bumped into 7.1.0 due to a soundness fix (a breaking change) as follows:</p>
<p>Previously, the empty array <code>[||]</code> was polymorphic. This happens to be true, since in native an array is not resizable, so users cannot do anything with it. But in JS, we introduced a binding for <code>push</code> which can change the size of an array dynamically. In this case, an empty array cannot be polymorphic any more.</p>
<p>Removing <code>push</code> is possible, but it makes arrays in JS context less useful. To fix this issue while keeping <code>push</code>, we make <code>[||]</code> weakly typed so that its type inference is deferred until the first time it is used. If it is never used across the module, it has to be annotated with a concrete type; otherwise, the type checker will complain.</p>
<p>Several highlighted features are listed as follows:</p>
<h2><a class="anchor" aria-hidden="true" id="raw-javascript-parsing-checking"></a><a href="#raw-javascript-parsing-checking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Raw JavaScript Parsing/Checking</h2>
<p>BuckleScript allows users to embed raw JavaScript code as an escape hatch; it used to treat such piece of code as a black box.</p>
<p>In this release we vendor a JavaScript parser (thanks to <a href="https://github.com/facebook/flow">flowtype</a>) for syntax checking and simple semantics analysis over <code>raw</code>. This is on-going work, but it is already useful now.</p>
<p>First, we now report syntax errors properly for <code>raw</code>.</p>
<p>Second, for simple semantics analysis, we can tell whether the code inside raw is a function or not and the arity of raw function:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> f = [%raw <span class="hljs-string">"function(x){return x}"</span>]
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> f = <span class="hljs-attribute">[%raw "function(x){return x}"]</span>;
</code></pre>
<p>Now we know <code>f</code> is a function declaration with no side effect; it can be removed by the dead code analyzer if not used. We also know its arity so that when it's called we know whether it's fully applied or not.</p>
<p>Because this sort of information can be derived from <code>raw</code> directly, the special <code>raw</code> form we introduced as follows is no longer needed:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> f = <span class="hljs-keyword">fun</span>%raw x -&gt; {|x|}
</code></pre>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">let</span> f = <span class="hljs-attribute">[%raw x =&gt; {|x|}]</span>;
</code></pre>
<p>To reduce interop API surface, this feature will now be discouraged.</p>
<p>We're also exploring using such knowledge on JS literals and regexes checking.</p>
<h2><a class="anchor" aria-hidden="true" id="unboxed-types"></a><a href="#unboxed-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unboxed Types</h2>
<p>One major feature introduced in this release is <strong>unboxed types</strong> which is blogged <a href="https://bucklescript.github.io/blog/2019/12/20/release-7-02">here</a>.</p>
<h2><a class="anchor" aria-hidden="true" id="uniform-warning-system"></a><a href="#uniform-warning-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Uniform Warning System</h2>
<p>Previously warnings are reported in two ways:</p>
<ul>
<li>The OCaml compiler style: <code>-w +10</code></li>
<li>Ad-hoc warnings introduced by flags <code>-bs-warn-unimplemented-external</code></li>
</ul>
<p>In this release, we  make such integration so that BuckleScript warnings are handled in the same way as OCaml's own warnings, for example, the warning attribute below can also turn off  BuckleScript warnings now.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@warning "-101"]</span>; <span class="hljs-operator">/</span><span class="hljs-operator">/</span> file<span class="hljs-operator">-</span>level config
</code></pre>
<p>Based on this effort, we have changed all BuckleScript warnings into OCaml style warnings to reduce user-level complexity.</p>
<p>The newly introduced warnings are listed via <code>bsc -warn-help</code>:</p>
<pre><code class="hljs"><span class="hljs-symbol">101 </span>BuckleScript warning: Unused bs attributes
<span class="hljs-symbol">102 </span>BuckleScript warning: polymorphic comparison introduced (maybe unsafe)
<span class="hljs-symbol">103 </span>BuckleScript warning: about fragile FFI definitions
<span class="hljs-symbol">104 </span>BuckleScript warning: bs.deriving warning with customized message
<span class="hljs-symbol">105 </span>BuckleScript warning: the external <span class="hljs-keyword">name</span> is inferred from <span class="hljs-keyword">val</span> <span class="hljs-keyword">name</span> is unsafe from refactoring when changing value <span class="hljs-keyword">name</span>
<span class="hljs-symbol">106 </span>BuckleScript warning: Unimplemented primitive used:
<span class="hljs-symbol">107 </span>BuckleScript warning: Integer literal exceeds the range of representable integers of type <span class="hljs-keyword">int</span>
<span class="hljs-symbol">108 </span>BuckleScript warning: Uninterpreted delimiters (<span class="hljs-keyword">for</span> unicode)
</code></pre>
<p>We also recommend users to turn on <code>warnerror</code> and only disable warnings for some specific files.</p>
<p>We've also upgraded the Reason parser <code>refmt</code> to 3.6.0.</p>
<p>A full list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/27/whats-new-in-7-cont">What&#x27;s new in release 7 (cont)</a></h1><p class="post-meta">December 27, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>[EDIT pre Dec. 27th: yes, we know the dateline is wrong :-) the actual publish date of this post is November 28th, but we're not changing the dateline because that would break the published URL of the post.]</p>
<p>The second dev release <a href="https://github.com/BuckleScript/bucklescript/pull/3995">7.0.0-dev.2</a> is released for testing!</p>
<p>As we mentioned in the <a href="https://bucklescript.github.io/blog/2019/11/18/whats-new-in-7">previous post</a>, we compile records into js objects in this release. This makes the generated code more idiomatic, however, this is not enough to write idiomatic bindings to manipulate arbitrary js objects, since the key of js objects can be arbitrary which is not expressible in ReasonML syntax, so we support user level customization now, which makes idiomatic bindings really easy.</p>
<pre><code class="hljs css language-reason"><span class="hljs-keyword">type</span> entry = {
  <span class="hljs-attribute">[@bs.as "EXACT_MAPPING_TO_JS_LABEL"]</span>
  x: int,
  <span class="hljs-attribute">[@bs.as "EXACT_2"]</span>
  y: int,
  z: obj,
}
<span class="hljs-keyword">and</span> obj = {
  <span class="hljs-attribute">[@bs.as "hello"]</span>
  hi: int,
};

<span class="hljs-keyword">let</span> f4 = ({x, y, z: {hi}}) =&gt; (x <span class="hljs-operator">+</span> y <span class="hljs-operator">+</span> hi) <span class="hljs-operator">*</span> <span class="hljs-number">2</span>;

</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> entry  = {
  x : <span class="hljs-built_in">int</span>  ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"EXACT_MAPPING_TO_JS_LABEL"</span>]
  y : <span class="hljs-built_in">int</span> ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"EXACT_2"</span>]
  z : obj
} 
<span class="hljs-keyword">and</span> obj = {
  hi : <span class="hljs-built_in">int</span> ; [@bs.<span class="hljs-keyword">as</span> <span class="hljs-string">"hello"</span>]  
}    

<span class="hljs-keyword">let</span> f4  { x; y; z = {hi }} = 
  (x + y + hi) * <span class="hljs-number">2</span>
</code></pre>
<pre><code class="hljs css language-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f4</span>(<span class="hljs-params">param</span>) </span>{
  <span class="hljs-keyword">return</span> (((param.EXACT_MAPPING_TO_JS_LABEL + param.EXACT_2 | <span class="hljs-number">0</span>) + param.z.hello | <span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-number">1</span>);
}
</code></pre>
<p>As you can see, you can manipulate js objects using Reason pattern match syntax, the generated
code is highly efficient, more importantly, bindings to JS will be significantly simplifie.</p>
<p>Happy Hacking.</p>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/20/release-7-02">BuckleScript holiday release!</a></h1><p class="post-meta">December 20, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p><a href="https://github.com/BuckleScript/bucklescript/pull/4062">bs-platform@7.0.2-dev.1</a> is released for testing!</p>
<p>Try it via</p>
<pre><code class="hljs"><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">-g</span> <span class="hljs-selector-tag">bs-platform</span>@<span class="hljs-keyword">7</span>.<span class="hljs-keyword">0</span>.<span class="hljs-keyword">2</span>-<span class="hljs-keyword">dev</span>.<span class="hljs-keyword">1</span>
</code></pre>
<p>This release contains several bug fixes for <a href="https://github.com/facebook/reason">refmt</a>(updated from 3.5.1 to 3.5.4). We also spent quite some time improving the compiler performance. For example, we optimized our specialized hash based data structures, which means that we can expect a 5% better build time performance. We would like to collect more benchmark data, so we are happy for any feedback / benchmarks from our community!</p>
<p>A highlighting feature is that we added Generalized Unboxed Support (so called [@unboxed] annotations). Here's a short definition from the official OCaml Manual:</p>
<blockquote>
<p>unboxed can be used on a type definition if the type is a single-field record or a concrete type with a single constructor that has a single argument. It tells the compiler to optimize the representation of the type by removing the block that represents the record or the constructor (i.e. a value of this type is physically equal to its argument). In the case of GADTs, an additional restriction applies: the argument must not be an existential variable, represented by an existential type variable, or an abstract type constructor applied to an existential type variable.</p>
</blockquote>
<p><strong>Note</strong>: The beforementioned restriction about GADTs only applies to OCaml's native compiler, not to BuckleScript's JavaScript compilation. So we will get the maximum value with less confusing error messages!</p>
<p>The exciting thing about this feature is that we will now have more ways of expressing our programs in our typical type safe records and variants without sacrificing on runtime performance (&quot;zero cost interop&quot;).</p>
<p>The best way to understand this feature is by looking at the following examples:</p>
<p><strong>Unboxed variants:</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = <span class="hljs-constructor">A</span>(int);
<span class="hljs-keyword">let</span> x = <span class="hljs-constructor">A</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
</code></pre>
<p>As you can see, we are &quot;unboxing&quot; the <code>int</code> value from the internal variant representation, so the variant will get completely invisible to the runtime. Great for e.g. mapping to stringly typed JavaScript enums!</p>
<p><strong>Unboxed Records (1 field only)</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t2 = {f: string};
<span class="hljs-keyword">let</span> x = {f: <span class="hljs-string">"foo"</span>};
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">"foo"</span>;
</code></pre>
<p>The same principle as with variants. Now a lot of people will probably ask: &quot;Why would I ever want a 1 field record?&quot;. There are multiple reasons, one of them would be a <code>ref</code> type, which is just a syntax sugar for a <code>{ contents: 'a}</code> record.</p>
<p>Another use case is for expressing high rank polymorphism without cost:</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> r = {f: 'a. 'a =&gt; 'a};
<span class="hljs-keyword">let</span> map_pair = (r, (p1, p2)) =&gt; (r.f(p1), r.f(p2));
</code></pre>
<p><strong>Note:</strong> <code>'a. 'a =&gt; 'a</code> describes a polymorphic function interface, where <code>'a</code> can be called with many different types (e.g. <code>f(1)</code> and <code>f(&quot;hi&quot;)</code>). The compiler will not try to lock <code>'a</code> for the first type it sees (e.g. the <code>int</code>) on the first call site. The parameter <code>'a</code> is therefore polymorphic!</p>
<p>By <code>unboxing</code> those records with one polymorphic function,  we will get rid of <a href="https://github.com/BuckleScript/bucklescript/issues/4058">value restriction for our existing encoding of uncurried function</a>, this will be a major feature!</p>
<p><strong>Unboxed GADTs:</strong></p>
<p>Since GADTs are lesser known in Reason syntax, we also added some OCaml snippet to get a better idea of how the example data structure is defined.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-constructor">Any</span> ('a) : t; 

<span class="hljs-keyword">let</span> array = <span class="hljs-literal">[|</span><span class="hljs-constructor">Any</span>(<span class="hljs-number">3</span>), <span class="hljs-constructor">Any</span>(<span class="hljs-string">"a"</span>)<span class="hljs-literal">|]</span>;
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t
[@@unboxed]

<span class="hljs-keyword">let</span> <span class="hljs-built_in">array</span> = [|<span class="hljs-type">Any</span> <span class="hljs-number">3</span>; <span class="hljs-type">Any</span> <span class="hljs-string">"a"</span>|]
</code></pre>
<p>The examples above will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> array = [ <span class="hljs-number">3</span>, <span class="hljs-string">"a"</span>];
</code></pre>
<p>As you can already tell, this feature will give us way better possibilities to do interop with polymorphic array representations in JavaScript (without losing any type safetiness!).</p>
<p>As a more concrete use-case, this will give users the possibility to define types such as <code>int_or_string</code>.</p>
<p><strong>Note:</strong> Even if this GADT <code>t</code> contains an ADT <code>Any</code>, it doesn't mean that it's the same as <code>any</code> in TypeScript. An <code>Any</code> value is constrained to a certain contract (<code>'a -&gt; t</code>), the array <code>[|Any(3), Any(&quot;a&quot;)|]</code> is inferred as a <code>array(t)</code>. When users try to use <code>Any</code> values, they need to unpack them, process the value inside, and repack them again. Pretty neat, right?</p>
<h3><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>
<p>This release will introduce the <code>[@unbox]</code> annotation to give us better ways to do zero cost interop with variants, records, higher kinded polymorphic functions, and GADTs. Under the hood improvements will give us better performance as well!</p>
<p>We are really excited about these changes, and we hope so are you. Please check out our newest <code>bs-platform@7.0.2-dev.1</code> release and let us know if you find any issues!</p>
<p>A detailed list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
<p>Happy hacking!</p>
<h3><a class="anchor" aria-hidden="true" id="appendix"></a><a href="#appendix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appendix</h3>
<p><strong>A sophiscated explanation on why <code>unboxed</code> lifts some OCaml's type system limitations</strong></p>
<blockquote>
<p>structural types (objects, classes, polymorphic variants, functions, etc) in
OCaml are regular types, ocaml always do the expansion when dealing with such
types, there is some limitations for such structural types, for example, non
regular definitions are not allowed. Non structural types (variants, records)
does not have such limitations, with <code>unboxed</code>, we can use non structural
types as an indirection without changing its runtime representations.</p>
</blockquote>
</span></div></article></div><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/11/18/whats-new-in-7">What&#x27;s new in release 7</a></h1><p class="post-meta">November 18, 2019</p><div class="authorBlock"></div></header><article class="post-content"><div><span><p>The new major version of BuckleScript is coming -<a href="https://github.com/BuckleScript/bucklescript/pull/3968">7.0.0-dev.1</a> released for testing!</p>
<p>We are maintaining <code>5.*</code> and <code>6.*</code> for OCaml <code>4.02</code> and <code>4.06</code> for a while, since this release we are moving forward and focusing on release 7.* (for OCaml 4.06).</p>
<p>This is a major release comes with lots of nice features listed <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md">here</a>.</p>
<p>We talk about some highlights here</p>
<ul>
<li><p>refmt upgraded to latest, it comes with better error message</p></li>
<li><p>OCaml Records compiled into JS objects</p></li>
</ul>
<p>This is one of the most desired features, it is finally landed.</p>
<p>See the generated code below for excitement!</p>
<pre><code class="hljs css language-reasonml"><span class="hljs-keyword">type</span> t = {
  x: <span class="hljs-built_in">int</span>,
  y: <span class="hljs-built_in">int</span>,
  z: <span class="hljs-built_in">int</span>,
};

<span class="hljs-keyword">let</span> obj = {x: <span class="hljs-number">3</span>, y: <span class="hljs-number">2</span>, z: <span class="hljs-number">2</span>};

<span class="hljs-keyword">let</span> obj2 = {...obj, y: <span class="hljs-number">4</span>};
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> t = {
  x : <span class="hljs-built_in">int</span>;
  y : <span class="hljs-built_in">int</span>;
  z : <span class="hljs-built_in">int</span> 
}

<span class="hljs-keyword">let</span> obj = { x = <span class="hljs-number">3</span> ; y = <span class="hljs-number">2</span>; z = <span class="hljs-number">2</span>}

<span class="hljs-keyword">let</span> obj2 = { obj <span class="hljs-keyword">with</span> y = <span class="hljs-number">4</span>}
</code></pre>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>
};

<span class="hljs-keyword">var</span> obj = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">2</span>
};
</code></pre>
<p>This new change makes record much more useful and its interaction with <code>private</code> type; unboxed option type will make interop with JS much nicer!</p>
<p>As always, we continue improving our optimizer in various <a href="https://github.com/BuckleScript/bucklescript/pull/3966/files?file-filters%5B%5D=.js">commits</a>, we belive that not only a better language but also an implementation of high quality is key to push typed functional programming into industry.</p>
<p>Happy hacking!</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next" href="/blog/page2/">Next →</a></div></div></div></div></div><span></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>