<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>BuckleScript holiday release! · BuckleScript</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="[bs-platform@7.0.2-dev.1](https://github.com/BuckleScript/bucklescript/pull/4062) is released for testing!"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="BuckleScript holiday release! · BuckleScript"/><meta property="og:type" content="website"/><meta property="og:url" content="https://bucklescript.github.io/blog/2019/12/20/release-7-02"/><meta property="og:description" content="[bs-platform@7.0.2-dev.1](https://github.com/BuckleScript/bucklescript/pull/4062) is released for testing!"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/logos/bucklescript.png"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"/><link rel="alternate" type="application/atom+xml" href="https://bucklescript.github.io/blog/atom.xml" title="BuckleScript Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://bucklescript.github.io/blog/feed.xml" title="BuckleScript Blog RSS Feed"/><script type="text/javascript" src="/js/toggleSyntaxButton.js"></script><script type="text/javascript" src="/js/redirectToNewDoc.js"></script><script type="text/javascript" src="/js/pjax-api.min.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/en"><img class="logo" src="/img/logos/bucklescript.svg" alt="BuckleScript"/><h2 class="headerTitleWithLogo">BuckleScript</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/en/installation" target="_self">Docs</a></li><li class=""><a href="/docs/en/playground" target="_self">Try</a></li><li class=""><a href="/docs/en/stdlib-overview" target="_self">API</a></li><li class=""><a href="/docs/en/community" target="_self">Community</a></li><li class="siteNavGroupActive"><a href="/blog/" target="_self">Blog</a></li><span><li><a id="languages-menu" href="#"><img class="languages-icon" src="/img/language.svg" alt="Languages icon"/>English</a><div id="languages-dropdown" class="hide"><ul id="languages-dropdown-items"><li><a href="/ja">日本語</a></li><li><a href="/es-ES">Español</a></li><li><a href="/fr">Français</a></li><li><a href="/ko">한국어</a></li><li><a href="/pt-BR">Português (Brasil)</a></li><li><a href="/ru">Русский</a></li><li><a href="/zh-CN">中文</a></li><li><a href="/zh-TW">繁體中文</a></li><li><a href="https://crowdin.com/project/bucklescript" target="_blank" rel="noreferrer noopener">Help Translate</a></li></ul></div></li><script>
        const languagesMenuItem = document.getElementById("languages-menu");
        const languagesDropDown = document.getElementById("languages-dropdown");
        languagesMenuItem.addEventListener("click", function(event) {
          event.preventDefault();

          if (languagesDropDown.className == "hide") {
            languagesDropDown.className = "visible";
          } else {
            languagesDropDown.className = "hide";
          }
        });
      </script></span><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/bucklescript/bucklescript" target="_self">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Recent Posts</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Recent Posts</h3><ul class=""><li class="navListItem"><a class="navItem" href="/blog/2020/05/06/exception-encoding">A story of exception encoding in BuckleScript</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/04/13/release-7-3">What&#x27;s new in release 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/26/generalize-uncurry">Generalized uncurry support in BuckleScript 7.3</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/03/12/release-7-2">Announcing bs-platform  7.2</a></li><li class="navListItem"><a class="navItem" href="/blog/2020/02/20/loading-stdlib-in-memory">Loading stdlib from memory</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer postContainer blogContainer"><div class="wrapper"><div class="lonePost"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle"><a href="/blog/2019/12/20/release-7-02">BuckleScript holiday release!</a></h1><p class="post-meta">December 20, 2019</p><div class="authorBlock"></div></header><div><span><p><a href="https://github.com/BuckleScript/bucklescript/pull/4062">bs-platform@7.0.2-dev.1</a> is released for testing!</p>
<p>Try it via</p>
<pre><code class="hljs"><span class="hljs-selector-tag">npm</span> <span class="hljs-selector-tag">i</span> <span class="hljs-selector-tag">-g</span> <span class="hljs-selector-tag">bs-platform</span>@<span class="hljs-keyword">7</span>.<span class="hljs-keyword">0</span>.<span class="hljs-keyword">2</span>-<span class="hljs-keyword">dev</span>.<span class="hljs-keyword">1</span>
</code></pre>
<p>This release contains several bug fixes for <a href="https://github.com/facebook/reason">refmt</a>(updated from 3.5.1 to 3.5.4). We also spent quite some time improving the compiler performance. For example, we optimized our specialized hash based data structures, which means that we can expect a 5% better build time performance. We would like to collect more benchmark data, so we are happy for any feedback / benchmarks from our community!</p>
<p>A highlighting feature is that we added Generalized Unboxed Support (so called [@unboxed] annotations). Here's a short definition from the official OCaml Manual:</p>
<blockquote>
<p>unboxed can be used on a type definition if the type is a single-field record or a concrete type with a single constructor that has a single argument. It tells the compiler to optimize the representation of the type by removing the block that represents the record or the constructor (i.e. a value of this type is physically equal to its argument). In the case of GADTs, an additional restriction applies: the argument must not be an existential variable, represented by an existential type variable, or an abstract type constructor applied to an existential type variable.</p>
</blockquote>
<p><strong>Note</strong>: The beforementioned restriction about GADTs only applies to OCaml's native compiler, not to BuckleScript's JavaScript compilation. So we will get the maximum value with less confusing error messages!</p>
<p>The exciting thing about this feature is that we will now have more ways of expressing our programs in our typical type safe records and variants without sacrificing on runtime performance (&quot;zero cost interop&quot;).</p>
<p>The best way to understand this feature is by looking at the following examples:</p>
<p><strong>Unboxed variants:</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = <span class="hljs-constructor">A</span>(int);
<span class="hljs-keyword">let</span> x = <span class="hljs-constructor">A</span>(<span class="hljs-number">3</span>);
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
</code></pre>
<p>As you can see, we are &quot;unboxing&quot; the <code>int</code> value from the internal variant representation, so the variant will get completely invisible to the runtime. Great for e.g. mapping to stringly typed JavaScript enums!</p>
<p><strong>Unboxed Records (1 field only)</strong></p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t2 = {f: string};
<span class="hljs-keyword">let</span> x = {f: <span class="hljs-string">"foo"</span>};
</code></pre>
<p>will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">"foo"</span>;
</code></pre>
<p>The same principle as with variants. Now a lot of people will probably ask: &quot;Why would I ever want a 1 field record?&quot;. There are multiple reasons, one of them would be a <code>ref</code> type, which is just a syntax sugar for a <code>{ contents: 'a}</code> record.</p>
<p>Another use case is for expressing high rank polymorphism without cost:</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> r = {f: 'a. 'a =&gt; 'a};
<span class="hljs-keyword">let</span> map_pair = (r, (p1, p2)) =&gt; (r.f(p1), r.f(p2));
</code></pre>
<p><strong>Note:</strong> <code>'a. 'a =&gt; 'a</code> describes a polymorphic function interface, where <code>'a</code> can be called with many different types (e.g. <code>f(1)</code> and <code>f(&quot;hi&quot;)</code>). The compiler will not try to lock <code>'a</code> for the first type it sees (e.g. the <code>int</code>) on the first call site. The parameter <code>'a</code> is therefore polymorphic!</p>
<p>By <code>unboxing</code> those records with one polymorphic function,  we will get rid of <a href="https://github.com/BuckleScript/bucklescript/issues/4058">value restriction for our existing encoding of uncurried function</a>, this will be a major feature!</p>
<p><strong>Unboxed GADTs:</strong></p>
<p>Since GADTs are lesser known in Reason syntax, we also added some OCaml snippet to get a better idea of how the example data structure is defined.</p>
<pre><code class="hljs css language-reason"><span class="hljs-attribute">[@unboxed]</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-constructor">Any</span> ('a) : t; 

<span class="hljs-keyword">let</span> array = <span class="hljs-literal">[|</span><span class="hljs-constructor">Any</span>(<span class="hljs-number">3</span>), <span class="hljs-constructor">Any</span>(<span class="hljs-string">"a"</span>)<span class="hljs-literal">|]</span>;
</code></pre>
<pre><code class="hljs css language-ocaml"><span class="hljs-comment">(* OCaml *)</span>
<span class="hljs-keyword">type</span> t = 
  | <span class="hljs-type">Any</span> : <span class="hljs-symbol">'a</span> -&gt; t
[@@unboxed]

<span class="hljs-keyword">let</span> <span class="hljs-built_in">array</span> = [|<span class="hljs-type">Any</span> <span class="hljs-number">3</span>; <span class="hljs-type">Any</span> <span class="hljs-string">"a"</span>|]
</code></pre>
<p>The examples above will translate to following JS:</p>
<pre><code class="hljs css language-js"><span class="hljs-keyword">var</span> array = [ <span class="hljs-number">3</span>, <span class="hljs-string">"a"</span>];
</code></pre>
<p>As you can already tell, this feature will give us way better possibilities to do interop with polymorphic array representations in JavaScript (without losing any type safetiness!).</p>
<p>As a more concrete use-case, this will give users the possibility to define types such as <code>int_or_string</code>.</p>
<p><strong>Note:</strong> Even if this GADT <code>t</code> contains an ADT <code>Any</code>, it doesn't mean that it's the same as <code>any</code> in TypeScript. An <code>Any</code> value is constrained to a certain contract (<code>'a -&gt; t</code>), the array <code>[|Any(3), Any(&quot;a&quot;)|]</code> is inferred as a <code>array(t)</code>. When users try to use <code>Any</code> values, they need to unpack them, process the value inside, and repack them again. Pretty neat, right?</p>
<h3><a class="anchor" aria-hidden="true" id="conclusion"></a><a href="#conclusion" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Conclusion</h3>
<p>This release will introduce the <code>[@unbox]</code> annotation to give us better ways to do zero cost interop with variants, records, higher kinded polymorphic functions, and GADTs. Under the hood improvements will give us better performance as well!</p>
<p>We are really excited about these changes, and we hope so are you. Please check out our newest <code>bs-platform@7.0.2-dev.1</code> release and let us know if you find any issues!</p>
<p>A detailed list of changes is available here: <a href="https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702">https://github.com/BuckleScript/bucklescript/blob/master/Changes.md#702</a></p>
<p>Happy hacking!</p>
<h3><a class="anchor" aria-hidden="true" id="appendix"></a><a href="#appendix" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Appendix</h3>
<p><strong>A sophiscated explanation on why <code>unboxed</code> lifts some OCaml's type system limitations</strong></p>
<blockquote>
<p>structural types (objects, classes, polymorphic variants, functions, etc) in
OCaml are regular types, ocaml always do the expansion when dealing with such
types, there is some limitations for such structural types, for example, non
regular definitions are not allowed. Non structural types (variants, records)
does not have such limitations, with <code>unboxed</code>, we can use non structural
types as an indirection without changing its runtime representations.</p>
</blockquote>
</span></div></div><div class="blogSocialSection"></div></div><div class="blog-recent"><a class="button" href="/blog">Recent Posts</a></div></div></div><nav class="onPageNav"></nav></div><span></span></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '0fd97db83891aa20810559812d9e69ac',
                indexName: 'bucklescript',
                inputSelector: '#search_input_react',
                algoliaOptions: {"facetFilters":["lang:en"]}
              });
            </script></body></html>